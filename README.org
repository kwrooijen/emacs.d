* Kwrooijen Emacs Configuration

My personal Emacs configuration. This README is compiled using the
[[https://github.com/kwrooijen/wisdom][Wisdom Emacs configuration framework]]. You can find all the separate
org files in the org/ directory. Visuals inspired by [[https://github.com/doomemacs/doomemacs][Doom Emacs]] and
[[https://github.com/rougier/nano-emacs][Nano Emacs]].

[[https://raw.githubusercontent.com/kwrooijen/emacs.d/refs/heads/master/emacs.png]]

* Emacs Configuration Aggregation

#+STARTUP: showeverything
#+PRIORITY: 0

* Emacs Home directory
#+BEGIN_SRC emacs-lisp
(setq kwrooijen/emacs-directory (expand-file-name "~/.wisdom.d"))
#+END_SRC

* Mark ask Emacs
#+BEGIN_SRC emacs-lisp
(setenv "INSIDE_EMACS" "true")
#+END_SRC

* GCMH
:PROPERTIES:
:PACKAGE: gcmh
:STRAIGHT: t
:END:

** Hook :hook:
#+BEGIN_SRC emacs-lisp
(emacs-startup-hook . gcmh-mode)
#+END_SRC

* No Littering :init:
:PROPERTIES:
:PACKAGE: no-littering
:STRAIGHT: t
:END:

#+BEGIN_SRC emacs-lisp
(setq no-littering-etc-directory (expand-file-name "config/" user-emacs-directory))
(setq no-littering-var-directory (expand-file-name "data/" user-emacs-directory))
(setq lock-file-name-transforms `(("\\`/.*/\\([^/]+\\)\\'" ,(no-littering-expand-var-file-name "lock-files/") t)))
(setq backup-directory-alist `((".*" . ,(no-littering-expand-var-file-name "backups/"))))
(setq auto-save-file-name-transforms `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))

(require 'no-littering)
#+END_SRC

Don't prompt the user to override backups.

#+BEGIN_SRC emacs-lisp
(setq delete-old-versions t)
#+END_SRC

* Options


Disable the default mode-line on startup

#+BEGIN_SRC emacs-lisp
(setq mode-line-format nil)
#+END_SRC

** Simplify Emacs startup screen
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t
      inhibit-startup-screen t
      initial-scratch-message nil)
#+END_SRC

** Simplify confirmations
#+BEGIN_SRC emacs-lisp
(setq confirm-nonexistent-file-or-buffer nil
      ring-bell-function 'ignore)
(setq vc-follow-symlinks t)
(setopt use-short-answers t)
#+END_SRC

** Less notifications

#+BEGIN_SRC emacs-lisp
(setq warning-minimum-level :error)
#+END_SRC


** User interface

Show the current column in the mode-line

#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
#+END_SRC

** Programming preferences
#+BEGIN_SRC emacs-lisp
(setq fill-column 80
      tab-width 4)

(setq-default indent-tabs-mode nil)
#+END_SRC

** System
*** macOS
Use Command as Meta (Alt).
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'meta))
#+END_SRC

*** GnuPG
Force the gpg password prompt into the minibuffer instead of a gui popup.
#+BEGIN_SRC emacs-lisp
(setq epa-pinentry-mode 'loopback)
#+END_SRC

Remember passwords
#+BEGIN_SRC emacs-lisp
(setq epa-file-cache-passphrase-for-symmetric-encryption t)
#+END_SRC

*** Clipboard
When yanking (copying) text in Emacs, don't push to OS Clipboard
#+BEGIN_SRC emacs-lisp
(setq select-enable-clipboard nil)
#+END_SRC

** Whitespace management

Clean up whitespace from buffer before saving

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

* Evil

This loads a set of keybindings for evil in other modes as well as
setting the initial evil state in those modes. Setting this to nil
prevents this.

#+BEGIN_SRC emacs-lisp
(setq evil-want-keybinding nil)
#+END_SRC

* Other

Allow upcase and downcase region.

#+BEGIN_SRC emacs-lisp
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
#+END_SRC

* Suppress messages

** Less messages

Don't print to a message whenever a file is saved. Failing to save a
file still messages.

#+BEGIN_SRC emacs-lisp
(setq save-silently t)
#+END_SRC

Disable the Emacs default startup message

#+BEGIN_SRC emacs-lisp
(defun display-startup-echo-area-message ()
  (message "")))
#+END_SRC

** Suppressing specific functions

#+BEGIN_SRC emacs-lisp
(setq warning-suppress-log-types '((org-roam)))
#+END_SRC

Show a stack trace when a specific message is sent. This allows you to
retrieve the origin of a `message` call.

~(setq debug-on-message "Position saved to mark ring")~


Add any function names to ~kwrooijen/suppress-message-functions~ to
suppress their messages. Restart is required for this to take effect.

#+BEGIN_SRC emacs-lisp
(defcustom kwrooijen/suppress-message-functions
  '(org-mark-ring-push sh-set-shell)
  "List of functions to suppress."
  :type '(repeat string)
  :group 'kwrooijen)

(defun kwrooijen/suppress-function-message (old-fun &rest args)
  (cl-flet ((silence (&rest args1) (ignore)))
    (advice-add 'message :around #'silence)
    (unwind-protect
         (apply old-fun args)
      (advice-remove 'message #'silence))))


(dolist (f kwrooijen/suppress-message-functions)
  (advice-add f :around #'kwrooijen/suppress-function-message))
#+END_SRC

** Disable mail functions

#+BEGIN_SRC emacs-lisp
(setq ffap-url-regexp nil)
(setq browse-url-mailto-function nil)
#+END_SRC

#+STARTUP: showeverything
#+PRIORITY: 1

* System

** Options
#+BEGIN_SRC emacs-lisp
(defcustom kwrooijen/system-leader-key "SPC"
  "The leader key for system commands."
  :type 'string
  :group 'kwrooijen)

(defcustom kwrooijen/system-local-leader-key "'"
  "The local leader key for system commands."
  :type 'string
  :group 'kwrooijen)

(defcustom kwrooijen/system-leader-keymaps '(override)
  "The keymaps in which the leader key is active."
  :type 'list
  :group 'kwrooijen)
#+END_SRC

** Disable F-keys
#+BEGIN_SRC emacs-lisp
(dotimes (i 12)
  (global-unset-key (kbd (format "<f%d>" (1+ i)))))
#+END_SRC

* Exec Path from Shell
:PROPERTIES:
:PACKAGE: exec-path-from-shell
:STRAIGHT: t
:END:

A GNU Emacs library to ensure environment variables inside Emacs look
the same as in the user's shell.

** Config :config:

Initialize environment from the user’s shell.

#+BEGIN_SRC emacs-lisp
(exec-path-from-shell-initialize)
#+END_SRC

Set the environment variable $NAME from the user’s shell.

#+BEGIN_SRC emacs-lisp
(exec-path-from-shell-copy-env "SSH_AUTH_SOCK")
#+END_SRC

* Which Key
:PROPERTIES:
:PACKAGE: which-key
:STRAIGHT: t
:END:

Show previews of keybindings when pressing the leader key or other prefix keys.

** Config :config:
#+BEGIN_SRC emacs-lisp
(which-key-mode 1)
#+END_SRC

* All the icons
:PROPERTIES:
:PACKAGE: all-the-icons
:STRAIGHT: t
:END:

Run M-x `all-the-icons-install-fonts` manually

* Dash
:PROPERTIES:
:PACKAGE: dash
:STRAIGHT: t
:END:

* General
:PROPERTIES:
:PACKAGE: general
:STRAIGHT: t
:END:

** Config :config:

Advise ‘define-key’ to automatically unbind keys when necessary.
This will prevent errors when a sub-sequence of a key is already bound.

#+BEGIN_SRC emacs-lisp
(general-auto-unbind-keys)
#+END_SRC

Set up some basic equivalents for vim mapping functions.

#+BEGIN_SRC emacs-lisp
(general-evil-setup t)
#+END_SRC

Define Leader and Local Leader keymaps. The Leader keymap is active in
all modes, the Local Leader keymap is only active in specific
modes. These keys are configurable through the variables
‘kwrooijen/system-leader-key’ and ‘kwrooijen/system-local-leader-key’.

#+BEGIN_SRC emacs-lisp

(general-create-definer kwrooijen/leader
  :keymaps kwrooijen/system-leader-keymaps
  :states '(normal visual emacs)
  :prefix kwrooijen/system-leader-key

  "c" '(:ignore t :which-key "Compile")
  "g" '(:ignore t :which-key "Git")
  "s" '(:ignore t :which-key "Search")
  "b" '(:ignore t :which-key "Buffers")
  "f" '(:ignore t :which-key "Files")
  "d" '(:ignore t :which-key "Denote")
  "p" '(:ignore t :which-key "Project")
  "w" '(:ignore t :which-key "Window")
  "r" '(:ignore t :which-key "Resume")
  "h" '(:ignore t :which-key "Help")
  "t" '(:ignore t :which-key "Toggle"))

(kwrooijen/leader
  "c m" '(kwrooijen/make :which-key "Make"))

(general-create-definer kwrooijen/local-leader
  :keymaps kwrooijen/system-leader-keymaps
  :states '(normal visual)
  :prefix kwrooijen/system-local-leader-key)
#+END_SRC

** Bindings :config:

Global keybindings. These are not defined using the `:general` keyword
because General hasn't been loaded yet.

#+BEGIN_SRC emacs-lisp
(defun unpop-to-mark-command ()
  "Unpop off mark ring. Does nothing if mark ring is empty."
  (interactive)
      (when mark-ring
        (setq mark-ring (cons (copy-marker (mark-marker)) mark-ring))
        (set-marker (mark-marker) (car (last mark-ring)) (current-buffer))
        (when (null (mark t)) (ding))
        (setq mark-ring (nbutlast mark-ring))
        (goto-char (marker-position (car (last mark-ring))))))

(let ((frame (framep (selected-frame))))
  (or (eq  t  frame)
      (eq 'pc frame)
      (define-key input-decode-map
                  (kbd "C-[")
                  [control-bracketleft])))

(general-define-key
 :states '(insert normal visual)
 "M-C" 'kwrooijen/capitalize-previous-word
 "M-c" 'clipboard-kill-ring-save
 "M-v" 'clipboard-yank
 "M-q" 'fill-paragraph
 "M-+" 'align-regexp
 [control-bracketleft] 'pop-to-mark-command
 "C-]" 'unpop-to-mark-command)

(general-define-key
 :states '(insert)
 :keymaps 'prog-mode-map
 "M-RET" 'evil-open-below)
#+END_SRC

Window keys

#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "w q" '(kill-current-buffer :which-key "Kill buffer")
  "w j" 'windmove-down
  "w k" 'windmove-up
  "w h" 'windmove-left
  "w l" 'windmove-right
  "w t" '(transpose-window-layout :repeat t)
  "w c" '(window-layout-rotate-clockwise :repeat t)
  "w C" '(window-layout-rotate-anticlockwise :repeat t)
  "w a" 'window-layout-flip-leftright
  "w d" 'window-layout-flip-leftright
  "w w" 'window-layout-flip-topdown
  "w s" 'window-layout-flip-topdown
  "w i" 'widen)
#+END_SRC

Resume keys

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/select-minibuffer ()
  "Make the active minibuffer the selected window."
  (interactive)
  (when-let ((minibuffer-window (active-minibuffer-window)))
    (select-window minibuffer-window)))

(kwrooijen/leader
  "r b" '(kwrooijen/select-minibuffer :which-key "Select minibuffer"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(general-define-key
 :keymaps 'minibuffer-mode-map
 "M--" 'describe-key
 "M-v" 'clipboard-yank
 "M-k" 'previous-line-or-history-element
 "M-j" 'next-line-or-history-element)
#+END_SRC

Add separate describe key hotkey (useful when C-h is rebound, or in minibuffer)
#+BEGIN_SRC emacs-lisp
(general-define-key
 "M-9" 'describe-key)
#+END_SRC

Navigation

#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "f r" '(kwrooijen/dired-project-root :which-key "Open project root in Dired")
  "f f" '(find-file :which-key "Find File")
  "f d" '(dired-jump :which-key "Open current directory")
  "f c" '(org-clock-multi-clock-goto :which-key "Go to active clock"))
#+END_SRC

Buffer

#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "b b" '(switch-to-buffer :which-key "Switch to Buffer"))
#+END_SRC

Help

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/describe-face ()
  (interactive)
  (let ((hl-line-p (bound-and-true-p hl-line-mode))
        (buf (current-buffer)))
    (when hl-line-p
      (hl-line-mode -1))
    (unwind-protect
        (call-interactively #'describe-face)
      (when hl-line-p
        ;; Re-enable AFTER this command fully finishes
        (run-at-time
         0 nil
         (lambda (b)
           (when (buffer-live-p b)
             (with-current-buffer b
               (hl-line-mode 1))))
         buf)))))

(kwrooijen/leader
  "h a" '(kwrooijen/describe-face :which-key "Describe face")
  "h k" '(describe-key :which-key "Describe key")
  "h f" '(describe-function :which-key "Describe function")
  "h v" '(describe-variable :which-key "Describe variable"))
#+END_SRC

#+LEXICAL_BINDING: nil
#+PRIORITY: 2

* Theme
:PROPERTIES:
:PACKAGE: embellish-theme
:END:

Font and color utilities. Theme faces are handled by the embellish-theme
package (loaded in =init.el=, applied in =visual.org=).

** Color Reference

Use =M-x kwrooijen/hex-colors-enable= to preview colors in this buffer.

| Semantic    | Hex     | Description                          |
|-------------+---------+--------------------------------------|
| strong      | #FFFFFF | Primary emphasis, bold text          |
| foreground  | #ECEFF4 | Default text                         |
| subtle      | #434C5E | Secondary, muted elements            |
| faded       | #616E88 | De-emphasized, comments              |
| salient     | #81A1C1 | Accent, links, keywords              |
| popout      | #D08770 | Strings, special callouts            |
| error       | #BF616A | Error states                         |
| warning     | #FFC16D | Warning states                       |
| success     | #A3BE8C | Success states                       |
| info        | #88C0D0 | Informational highlights             |
| background  | #222436 | Main background                      |
| darken      | #1e2030 | Darker background (sidebars, blocks) |
| highlight   | #2f334d | Selection, cursor line               |

* Utilities

** Hex Color Preview

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/hex-colors-enable ()
  "Enable hex color preview in current buffer."
  (interactive)
  (font-lock-add-keywords
   nil
   '(("#[[:xdigit:]]\\{6\\}"
      (0 (put-text-property (match-beginning 0) (match-end 0)
                            'face (list :foreground (match-string-no-properties 0)))))))
  (font-lock-flush))

(defun kwrooijen/hex-colors-disable ()
  "Disable hex color preview in current buffer."
  (interactive)
  (font-lock-remove-keywords
   nil
   '(("#[[:xdigit:]]\\{6\\}"
      (0 (put-text-property (match-beginning 0) (match-end 0)
                            'face (list :foreground (match-string-no-properties 0)))))))
  (font-lock-flush))
#+END_SRC

* Package: Web Mode
:PROPERTIES:
:PACKAGE: web-mode
:DEFER: t
:END:

** Init :init:

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
#+END_SRC

* Package: Shr :config:
:PROPERTIES:
:PACKAGE: shr
:DEFER: t
:END:

#+BEGIN_SRC emacs-lisp
(require 'embellish-font)
(set-face-attribute 'shr-text nil
                    :family embellish-font-family
                    :weight 'light)
#+END_SRC

#+STARTUP: showeverything
#+PRIORITY: 3

* Package: key-chord
:PROPERTIES:
:PACKAGE: key-chord
:AFTER: evil
:END:

*** Options

#+BEGIN_SRC emacs-lisp
(defcustom kwrooijen/key-chord-save-and-evil-normal-key "xs"
  "Key combination for keychord to save buffer and switch to Evil
normal state."
  :type 'string
  :group 'kwrooijen)

(defcustom kwrooijen/key-chord-evil t
  "Whether to use key-chord with Evil. If t, key-chord will be
configured for Evil mode"
  :type 'boolean
  :group 'kwrooijen)
#+END_SRC

** Straight :straight:

[[https://github.com/emacsorphanage/key-chord/issues/6][Because of an issue]] in key-chord, we specify the git hash.

#+BEGIN_SRC emacs-lisp
(key-chord
 :host github
 :repo "emacsorphanage/key-chord"
 :commit "68264d09593e69c1d4773859ac570bd9feb008d9")
#+END_SRC

** Hooks :hook:

+ Add `key-chord-mode` to all programming modes.
+ Add `key-chord-mode` to `isearch` to allow breaking out of search using key-chord.

#+BEGIN_SRC emacs-lisp
((prog-mode . key-chord-mode)
 (text-mode . key-chord-mode)
 (isearch-mode . key-chord-mode))
#+END_SRC

** Config :config:

kwrooijen/key-chord provides a function to return to normal mode and
save the buffer. Therefore, instead of `Esc + :w + RET` you simply
type (by default) `xs`. Configurable through
`kwrooijen/key-chord-save-and-evil-normal-key`.

#+BEGIN_SRC emacs-lisp
(when (and kwrooijen/key-chord-evil
           kwrooijen/key-chord-save-and-evil-normal-key)
  (defun kwrooijen/key-chord-evil-normal-state-and-save ( )
    "Switch to Evil normal state and save buffer."
    (interactive)
    (evil-normal-state)
    (save-buffer))

  (key-chord-define-global
   kwrooijen/key-chord-save-and-evil-normal-key
  'kwrooijen/key-chord-evil-normal-state-and-save))
#+END_SRC

#+PRIORITY: 3
* Functions

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/find-and-load-file (file)
  (let ((file-path (expand-file-name file)))
    (when (file-exists-p file-path)
      (load-file file-path))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/upgrade-packages ()
  "Upgrades all packages to their latest version (using Straight.el) and updates the lockfile."
  (interactive)
  (straight-pull-all)
  ;; KEY CHORD WORKING VERSION
  ;; ("key-chord" . "fc75b1451759121601110da8ddfadcf5156318af")
  (straight-freeze-versions))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/capitalize-previous-word ()
  (interactive)
  (save-excursion
    (backward-word)
    (capitalize-word 1)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/tab ()
  (interactive)
  (or (copilot-accept-completion)
      (indent-for-tab-command)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/toggle-word-line-wrap ()
  (interactive)
  (toggle-truncate-lines))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-latex-preview-all ()
  "Preview all LaTeX fragments in the current buffer."
  (interactive)
  (org-latex-preview '(16)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-images-increase ()
  (interactive)
  (when (equal org-image-actual-width t)
    (setq org-image-actual-width 1200))
  (setq org-image-actual-width (+ (or org-image-actual-width 1000) 250))
  (kwrooijen/org-toggle-inline-images-refresh))

(defun kwrooijen/org-images-decrease ()
  (interactive)
  (when (equal org-image-actual-width t)
    (setq org-image-actual-width 1200))
  (setq org-image-actual-width (- (or org-image-actual-width 1000) 250))
  (kwrooijen/org-toggle-inline-images-refresh))

(defun kwrooijen/org-toggle-inline-images-refresh ()
  "Force refresh of inline images in the current buffer."
  (interactive)
  (org-remove-inline-images)
  (org-display-inline-images))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-focus-this-heading ()
  "Close all other Org headings except the current one."
  (interactive)
  (org-overview)
  (org-reveal)
  (org-show-subtree))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/indent-buffer ()
  (interactive)
  (indent-region (point-min) (point-max)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/load-secret-env ()
  "Load environment variables from FILE-PATH into Emacs."
  (interactive)
  (let ((files '("~/.env.gpg" "~/.env-emacs.gpg")))
    (dolist (file files)
      (when (file-exists-p file)
        (with-temp-buffer
          (insert-file-contents file)
          (goto-char (point-min))
          (while (not (eobp))
            (let ((line (buffer-substring-no-properties
                         (line-beginning-position)
                         (line-end-position))))
              (when (string-match "^export \\([^=]+\\)=\\(.*\\)$" line)
                (setenv (match-string 1 line)
                        (match-string 2 line))))
            (forward-line 1)))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/read-file (file)
  (with-temp-buffer
    (insert-file-contents (expand-file-name file))
    (buffer-string)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/project-root ()
  (project-root (project-current)))

(defun kwrooijen/project-name ()
  (project-name (project-current)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/make--targets (makefile)
  "Parse MAKEFILE and return a list of target names."
  (when (file-exists-p makefile)
    (with-temp-buffer
      (insert-file-contents makefile)
      (let (targets)
        (goto-char (point-min))
        (while (re-search-forward "^\\([a-zA-Z0-9_-][a-zA-Z0-9._-]*\\):" nil t)
          (push (match-string 1) targets))
        (nreverse targets)))))

(defun kwrooijen/make ()
  "Select a Makefile target via completing-read and run it in a unique buffer."
  (interactive)
  (let* ((default-directory (or (kwrooijen/project-root) default-directory))
         (makefile (expand-file-name "Makefile" default-directory))
         (targets (kwrooijen/make--targets makefile))
         (target (completing-read "Make: " targets nil t))
         (buf-name (format "make:%s:%s" (kwrooijen/project-name) target)))
    (pop-to-buffer (make-comint-in-buffer buf-name nil "make" nil target))))

(defmacro comment (&rest _))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/dired-project-root ()
  (interactive)
  (let ((project-root (project-root (project-current t))))
    (dired project-root)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/remove-empty-lines ()
  "Remove all empty lines in the current buffer or region."
  (interactive)
  (let ((start (if (use-region-p) (region-beginning) (point-min)))
        (end (if (use-region-p) (region-end) (point-max))))
    (save-excursion
      (goto-char start)
      (while (re-search-forward "^[[:space:]]*\n" end t)
        (replace-match "")))))
#+END_SRC

#+PRIORITY: 3

* Embellish
:PROPERTIES:
:PACKAGE: embellish
:END:

Configure theme-dependent settings for embellish and enable
subwindow mode. The base =embellish-mode= is enabled in =init.el=.

** Init :init:

#+BEGIN_SRC emacs-lisp
(load-theme 'embellish-winter-night t)
(embellish-mode 1)
#+END_SRC



* Highlight TODO
:PROPERTIES:
:PACKAGE: hl-todo
:STRAIGHT: t
:END:

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(hl-todo-keyword-faces
 '(("TODO"   . "#FF0000")
   ("FIXME"  . "#FF0000")
   ("DEBUG"  . "#A020F0")
   ("GOTCHA" . "#FF4500")
   ("STUB"   . "#1E90FF")))
#+END_SRC

** hook :hook:
#+BEGIN_SRC emacs-lisp
(prog-mode . hl-todo-mode)
#+END_SRC

* Highlight numbers
:PROPERTIES:
:PACKAGE: highlight-numbers
:STRAIGHT: t
:END:
** Hook :hook:
#+BEGIN_SRC emacs-lisp
((prog-mode . highlight-numbers-mode)
 (org-mode . highlight-numbers-mode))
#+END_SRC

* Dimmer
:PROPERTIES:
:PACKAGE: dimmer
:STRAIGHT: t
:END:

** Init :init:
#+BEGIN_SRC emacs-lisp
(require 'dimmer)
#+END_SRC

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(dimmer-fraction 0.8)
(dimmer-watch-frame-focus-events nil)
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(defgroup kwrooijen/minibuffer-dim nil
  "Customization for minibuffer-aware dimming rules."
  :group 'convenience)

(setq kwrooijen/minibuffer-dim-excluded-commands
  '(consult-line
    consult-yank-from-kill-ring
    consult-ripgrep
    magit-discard
    anzu-query-replace
    org-schedule
    kwrooijen/consult-ripgrep-symbol-at-point)
)

(defcustom kwrooijen/minibuffer-dim-excluded-commands
  '(consult-line
    consult-yank-from-kill-ring
    consult-ripgrep
    magit-discard
    anzu-query-replace
    org-schedule
    kwrooijen/consult-ripgrep-symbol-at-point)

  "Commands for which the original window should not be dimmed.
When the minibuffer is activated by one of these commands,
the selected window will be restored (not dimmed)."
  :type '(repeat symbol))

(defun kwrooijen/dimmer-dim-all ()
  "Dim all buffers."
  (mapc (lambda (buf)
          (with-current-buffer buf
            (unless (minibufferp)
              (dimmer-dim-buffer buf dimmer-fraction))))
        (dimmer-visible-buffer-list)))

(defun kwrooijen/minibuffer-dim-all-initialize ()
  "Dim all buffers except for commands listed in `kwrooijen/minibuffer-dim-excluded-commands'."
  (kwrooijen/dimmer-dim-all)
  (when (memq this-command kwrooijen/minibuffer-dim-excluded-commands)
    (dimmer-restore-buffer (window-buffer (minibuffer-selected-window)))))

;;;###autoload
(define-minor-mode kwrooijen/minibuffer-dim-mode
  "Toggle dimming adjustments for Minibuffer."
  :global t
  (if kwrooijen/minibuffer-dim-mode
      (progn
        (add-to-list 'dimmer-exclusion-regexp-list ".*Minibuf.*")

        (add-hook 'minibuffer-setup-hook #'kwrooijen/minibuffer-dim-all-initialize)
        (add-hook 'minibuffer-exit-hook #'dimmer-restore-all))

        (remove-hook 'minibuffer-setup-hook #'kwrooijen/minibuffer-dim-all-initialize)
        (remove-hook 'minibuffer-exit-hook #'dimmer-restore-all)))

(kwrooijen/minibuffer-dim-mode)
#+END_SRC
* Hl line mode
:PROPERTIES:
:PACKAGE: hl-line
:END:

** Hook :hook:
#+BEGIN_SRC emacs-lisp
((prog-mode . hl-line-mode)
 (text-mode . hl-line-mode)
 (messages-buffer-mode . hl-line-mode))
#+END_SRC

#+PRIORITY: 4

* Paredit
:PROPERTIES:
:PACKAGE: paredit
:STRAIGHT: t
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(define-key paredit-mode-map (kbd "M-(") 'paredit-wrap-sexp)
(define-key paredit-mode-map (kbd "M-{") 'paredit-wrap-curly)
(define-key paredit-mode-map (kbd "M-[") 'paredit-wrap-square)
(define-key paredit-mode-map (kbd "M-C-p") nil)
(define-key paredit-mode-map (kbd "M-C-n") nil)
#+END_SRC

* Lispyville
:PROPERTIES:
:PACKAGE: lispyville
:STRAIGHT: t
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(lispyville--define-key 'normal (kbd "M-J") #'mc/mark-next-like-this)
(lispyville--define-key 'normal (kbd "M-K") #'mc/mark-previous-like-this)
#+END_SRC

* Lispy
:PROPERTIES:
:PACKAGE: lispy
:STRAIGHT: t
:AFTER: evil-collection
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(defun lispy--clojure-middleware-load ())
(defun sexp-at-point ()
  (interactive)
  (let ((current (point))
        (end (save-excursion (lispy-different) (point))))
    (buffer-substring current end)))

(defun cider-tap-sexp ()
  (interactive)
  (cider-interactive-eval (format "(tap> %s)" (cider-eval-sexp-at-point))))

(defun lispy--mode-p ()
  (or (lispy-left-p)
      (lispy-right-p)))

(defun lispy-brackets-or-barf (arg)
  (interactive "P")
  (if (lispy--mode-p)
      (lispy-barf 1)
    (lispy-brackets arg)))

(defun lispy-left-insert ()
  (interactive)
  (when (not (lispy--mode-p))
    (lispy-left 1))
  (when (not (lispy--mode-p))
    (beginning-of-defun))
  (when (lispy--mode-p)
    (evil-insert-state 1)))

(defun lispy-right-insert ()
  (interactive)
  (when (not (lispy--mode-p))
    (lispy-right 1))
  (when (not (lispy--mode-p))
    (end-of-defun))
  (when (lispy--mode-p)
    (evil-insert-state 1)))

(defun lispy-o ()
  (interactive)
  (when (lispy-left-p)
    (lispy-different))
  (lispy-newline-and-indent-plain))

(defun kwrooijen/lispy-delete-line ()
  (interactive)
  (let ((left? (lispy-left-p))
        (current (point)))
    (when (lispy-right-p)
      (lispy-different))
    (kill-sexp)
    (save-excursion
      (lispy-left-insert))
    (when (not (lispy--mode-p))
      (evil-join (save-excursion (beginning-of-line) (point))
                 (save-excursion (end-of-line) (point))))
    (indent-for-tab-command)
    (when (not (eq left? (lispy-left-p)))
      (lispy-different))))

(defun lispy-global-teleport (arg)
  (interactive "p")
  (let ((lispy-teleport-global t))
    (lispy-teleport arg)))

(add-hook 'lispy-mode-hook
          (lambda ()
            (define-key lispy-mode-map (kbd "M-[") #'lispy-wrap-brackets)
            (define-key lispy-mode-map (kbd "M-{") #'lispy-wrap-braces)
            (define-key lispy-mode-map (kbd "M-(") #'lispy-wrap-round)
            (define-key lispy-mode-map (kbd "C-k") nil)
            (define-key lispy-mode-map (kbd "M-o") #'pop-to-mark-command)
            (define-key lispyville-mode-map (kbd "M-o") #'pop-to-mark-command)

            (evil-define-key 'insert lispy-mode-map "]" #'lispy-slurp)
            (evil-define-key 'insert lispy-mode-map "[" #'lispy-brackets-or-barf)
            (evil-define-key 'insert lispy-mode-map "{" #'lispy-braces)
            (evil-define-key 'insert lispy-mode-map (kbd "C-d") #'lispy-describe-inline)
            (evil-define-key 'insert lispy-mode-map (kbd "C-e") #'lispy-arglist-inline)
            (evil-define-key 'normal lispy-mode-map (kbd "M-a") #'lispy-left-insert)
            (evil-define-key 'normal lispyville-mode-map (kbd "M-a") #'lispy-left-insert)
            (evil-define-key 'normal lispyville-mode-map (kbd "M-o") #'pop-to-mark-command)
            (evil-collection-define-key 'normal 'lispy-mode-map (kbd "M-d") #'lispy-kill-word)
            (evil-collection-define-key 'normal 'lispy-mode-map (kbd "D") #'paredit-kill)
            (lispy-define-key lispy-mode-map "v" #'er/expand-region)
            (lispy-define-key lispy-mode-map "o" 'lispy-o)
            (lispy-define-key lispy-mode-map "M-o" 'pop-to-mark-command)
            (lispy-define-key lispy-mode-map "x" 'kwrooijen/lispy-delete-line)
            (lispy-define-key lispy-mode-map "d" 'lispy-different)
            (lispy-define-key lispy-mode-map "i" 'indent-sexp)
            (lispy-define-key lispy-mode-map "x" 'lispyville-delete)
            (lispy-define-key lispy-mode-map "A" 'lispy-ace-symbol-replace)
            (lispy-define-key lispy-mode-map "H" 'special-lispy-move-left)
            (lispy-define-key lispy-mode-map "J" 'special-lispy-down-slurp)
            (lispy-define-key lispy-mode-map "K" 'special-lispy-up-slurp)
            (lispy-define-key lispy-mode-map "L" 'special-lispy-move-right)
            (lispy-define-key lispy-mode-map "I" 'evil-insert-state)
            (lispy-define-key lispy-mode-map "T" 'lispy-global-teleport)
            (define-key lispy-mode-map (kbd "M-a") 'lispy-left-insert)
            (define-key lispy-mode-map (kbd "M-e") 'lispy-right-insert)
            ;; Fix for copilot
            (lispy-define-key lispy-mode-map "j" 'kwrooijen/special-lispy-down)
            (lispy-define-key lispy-mode-map "k" 'kwrooijen/special-lispy-up)))


(defface ignore-paren-face
  `((t (:inherit embellish-theme-subtle-fg-face))) "")

(add-hook 'lispy-mode-hook
          (lambda ()
            (font-lock-add-keywords nil '((")" . 'ignore-paren-face)))
            (font-lock-add-keywords nil '(("}" . 'ignore-paren-face)))
            (font-lock-add-keywords nil '(("]" . 'ignore-paren-face)))))


(defun kwrooijen/special-lispy-down ()
  "lispy down is broken with copilot, so we need to override it."
  (interactive)
  (if (copilot--overlay-visible)
      (insert "j")
    (special-lispy-down)))

(defun kwrooijen/special-lispy-up ()
  "lispy up is broken with copilot, so we need to override it."
  (interactive)
  (if (copilot--overlay-visible)
      (insert "k")
    (special-lispy-up)))

(defun kwrooijen/recenter (&rest x)
  (evil-scroll-line-to-center (line-number-at-pos)))


(advice-add 'special-lispy-down :after #'kwrooijen/recenter)
(advice-add 'special-lispy-up :after #'kwrooijen/recenter)
(add-hook 'lispy-mode-hook #'show-paren-mode)
(add-hook 'lispy-mode-hook #'paredit-mode)
(add-hook 'lispy-mode-hook #'lispyville-mode)
#+END_SRC

* Iedit
:PROPERTIES:
:PACKAGE: iedit
:STRAIGHT: t
:END:

** Bindings :general:

#+BEGIN_SRC emacs-lisp
("M-i" 'iedit-mode)
#+END_SRC

* Expand region
:PROPERTIES:
:PACKAGE: expand-region
:STRAIGHT: t
:END:
** Bindings :general:
#+BEGIN_SRC emacs-lisp
("M-]" 'er/expand-region)
("M-[" 'er/contract-region)
#+END_SRC

* Multiple Cursors
:PROPERTIES:
:PACKAGE: multiple-cursors
:END:

** Straight :straight:

Use a custom version of multiple cursors which works with Evil.

#+BEGIN_SRC emacs-lisp
(multiple-cursors
             :host github
             :repo "kwrooijen/mc"
             :files (:defaults (:exclude "*.el.in")))
#+END_SRC

** Bindings :general:

#+BEGIN_SRC emacs-lisp
("M-P" 'mc/mark-previous-like-this)
("M-N" 'mc/mark-next-like-this)
#+END_SRC

** Custom :custom:

#+BEGIN_SRC emacs-lisp
(mc/list-file (file-name-concat kwrooijen/emacs-directory "db/mc-lists.el"))
#+END_SRC

** Config :config:

#+BEGIN_SRC emacs-lisp
(multiple-cursors-mode t)
#+END_SRC

* Smart Parens
:PROPERTIES:
:PACKAGE: smartparens
:STRAIGHT: t
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(require 'smartparens-config)
#+END_SRC

** Hook :hook:

Enable for all programming modes. Would this be ok for lisp modes?

#+BEGIN_SRC emacs-lisp
((prog-mode . smartparens-mode))
#+END_SRC


* Vundo
:PROPERTIES:
:PACKAGE:  vundo
:STRAIGHT: t
:END:

** General :general:
#+BEGIN_SRC emacs-lisp
(:states  'normal
 "u" 'undo
 "U" 'undo-redo)

("M-u" 'vundo)
#+END_SRC

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(vundo-window-max-height 6)
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'vundo-default nil :height 250)
#+END_SRC



* Undo Fu Session
:PROPERTIES:
:PACKAGE:  undo-fu-session
:STRAIGHT: t
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(undo-fu-session-global-mode)
#+END_SRC


* Super Save
:PROPERTIES:
:PACKAGE:  super-save
:STRAIGHT: t
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(super-save-mode +1)
(add-to-list 'super-save-triggers 'winum-select-window-1)
(add-to-list 'super-save-triggers 'winum-select-window-2)
(add-to-list 'super-save-triggers 'winum-select-window-3)
(add-to-list 'super-save-triggers 'winum-select-window-4)
(add-to-list 'super-save-triggers 'winum-select-window-5)
(add-to-list 'super-save-triggers 'winum-select-window-6)
(add-to-list 'super-save-triggers 'winum-select-window-7)
(add-to-list 'super-save-triggers 'winum-select-window-8)
(add-to-list 'super-save-triggers 'winum-select-window-9)
(add-to-list 'super-save-triggers 'winum-select-window-0)
#+END_SRC


* Avy
:PROPERTIES:
:PACKAGE:  avy
:STRAIGHT: t
:END:
** General :general:
#+BEGIN_SRC emacs-lisp
(general-define-key
 :states 'normal
 :keymaps 'evil-normal-state-map
 "[" #'avy-goto-char)
#+END_SRC

* Edit Indirect
:PROPERTIES:
:PACKAGE:  edit-indirect
:STRAIGHT: t
:END:

Edit regions in separate buffers, like org-edit-special but for any region.

** Config :config:

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-edit-subtree ()
  "Edit the current org subtree in an indirect buffer.
Use C-c C-c to commit changes, C-c C-k to abort.
If an indirect edit buffer already exists for this subtree, switch to it."
  (interactive)
  (org-back-to-heading t)
  (let* ((beg (point))
         (end (save-excursion (org-end-of-subtree t) (point)))
         (existing (edit-indirect--search-for-edit-indirect beg end)))
    (if existing
        (switch-to-buffer (overlay-get existing 'edit-indirect-buffer))
      (edit-indirect-region beg end t)
      (org-mode)
      (org-show-all)
      (add-hook 'kill-buffer-query-functions
                (lambda ()
                  (or (not (buffer-modified-p))
                      (yes-or-no-p "Edit-indirect buffer has unsaved changes. Kill anyway? ")))
                nil t))))
#+END_SRC

#+STARTUP: showeverything

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/insert-euro-symbol ()
  "Inserts the € symbol at the cursor's position."
  (interactive)
  (insert "€"))
#+END_SRC

* Evil
:PROPERTIES:
:PACKAGE: evil
:STRAIGHT: t
:END:

** Config :config:

#+BEGIN_SRC emacs-lisp
(evil-mode 1)
#+END_SRC

Recenter screen when searching forward / backwards
#+BEGIN_SRC emacs-lisp
(advice-add 'evil-search-next :after #'kwrooijen/recenter)
(advice-add 'evil-search-previous :after #'kwrooijen/recenter)
#+END_SRC

** Hook :hook:
#+BEGIN_SRC emacs-lisp
(minibuffer-setup . #'evil-insert-state)
#+END_SRC

** Bindings :general:

#+BEGIN_SRC emacs-lisp
(:states 'insert
         "C-$" 'kwrooijen/insert-euro-symbol)
#+END_SRC

* Evil Collection
:PROPERTIES:
:PACKAGE: evil-collection
:STRAIGHT: t
:AFTER: evil
:END:

** Config :config:

Evil collection makes it very hard to override the `[` key.
#+BEGIN_SRC emacs-lisp
(defvar kwrooijen/intercept-mode-map (make-sparse-keymap))

(define-minor-mode kwrooijen/intercept-mode
  "Intercept evil keys before evil-collection."
  :global t)

(kwrooijen/intercept-mode)

(dolist (state '(normal motion visual))
  (evil-make-intercept-map
   (evil-get-auxiliary-keymap kwrooijen/intercept-mode-map state t t)
   state))

(evil-define-key '(normal motion visual)
  kwrooijen/intercept-mode-map
  "[" #'avy-goto-char)

(evil-collection-init)
#+END_SRC

* Evil Nerd commenter
:PROPERTIES:
:PACKAGE: evil-nerd-commenter
:STRAIGHT: t
:AFTER: evil
:END:

** Bindings :general:

#+BEGIN_SRC emacs-lisp
("M-/" 'evilnc-comment-or-uncomment-lines)
#+END_SRC

* Evil Highlight Persist
:PROPERTIES:
:PACKAGE: evil-search-highlight-persist
:STRAIGHT: t
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(global-evil-search-highlight-persist t)
(advice-add 'keyboard-quit :before #'evil-search-highlight-persist-remove-all)
#+END_SRC


* Hl Line
:PROPERTIES:
:PACKAGE:  hl-line
:DEFER: t
:END:

** Config :config:

Disable hl-line-mode when entering visual mode, since hl-line and
visual use the same background.

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/hl-line-off ()
  (hl-line-mode -1))

(defun kwrooijen/hl-line-on ()
  (hl-line-mode 1))

(add-hook 'evil-visual-state-entry-hook #'kwrooijen/hl-line-off)
(add-hook 'evil-visual-state-exit-hook  #'kwrooijen/hl-line-on)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t; -*-

(require 'cl-lib)

(defvar navi-visual-overlay nil
  "")

(defvar navi-node nil
  "")

(defvar navi-position 'start
  "")

(defface navi-highlight
  '((((class color) (background light))
     :background "#393c4c" :foreground "white")
    (((class color) (background dark))
     :background "#393c4c" :foreground "white"))
  ""
  :group 'navi-faces)

(defcustom navi-use-hl-line t
  "Disable hl-line-mode in navi state."
  :type 'boolean
  :group 'navi)

(defcustom navi-hl-mode nil
  "hl-line-mode or global-hl-line-mode."
  :type 'symbol
  :group 'navi)

(defun navi-get-major-mode ()
  (interactive)
  (if (and (eq major-mode 'org-mode)
           (equal 'src-block (car (org-element-context))))
      (intern (format "%s-mode" (org-element-property :language (org-element-context))))
    major-mode))

(defun navi-node-length-of? (length)
  (let ((length length))
    (lambda (node)
      (= length (treesit--node-length node)))))

(defun navi-node-has-only-one-child? (node)
  (= 1 (length (treesit-node-children node))))

(defun navi-rules ()
  (let ((rules (intern (format "navi-rules:%s" (navi-get-major-mode)))))
    (when (boundp rules)
      (symbol-value rules))))

(defcustom navi-rules:ruby-ts-mode
  `(:navigation
    (("program"        . (:ignore t))
     ("."              . (:action navi-next-node :pred identity))
     (":"              . (:action navi-next-node :pred identity))
     ("::"             . (:action navi-next-node :pred identity))
     ("="              . (:action navi-next-node :pred identity))
     (","              . (:action navi-next-node :pred identity))
     ("def"            . (:action navi-next-shift-node :pred identity))
     ("end"            . (:action navi-next-shift-node :pred identity))
     ("{"              . (:action navi-next-shift-node :pred identity))
     ("}"              . (:action navi-next-shift-node :pred identity))
     ("("              . (:action navi-next-shift-node :pred identity))
     (")"              . (:action navi-next-shift-node :pred identity))
     ("\""             . (:action navi-next-shift-node :pred identity))
     ("\""             . (:action navi-next-shift-node :pred identity))
     ;; ("class"          . (:action navi-next-shift-node :pred ,(navi-node-length-of? 5)))
     ;; ("module"         . (:action navi-next-shift-node :pred ,(navi-node-length-of? 6)))
     ("body_statement" . (:action navi-next-shift-node :pred navi-node-has-only-one-child?)))
    :avy
    (("program"        . (:ignore t))
     ("."              . (:ignore t))
     (":"              . (:ignore t))
     ("::"             . (:ignore t))
     ("="              . (:ignore t))
     (","              . (:ignore t))
     ("def"            . (:ignore t))
     ("end"            . (:ignore t))
     ("{"              . (:ignore t))
     ("}"              . (:ignore t))
     ("("              . (:ignore t))
     (")"              . (:ignore t))
     ("\""             . (:ignore t))
     ("\""             . (:ignore t))
     ;; ("class"          . (:ignore t :pred ,(navi-node-length-of? 5)))
     ;; ("module"         . (:ignore t :pred ,(navi-node-length-of? 6)))
     ("body_statement" . (:ignore t))))
  ""
  :type '()
  :group 'navi)

(defun navi-outdated-p ()
  (if navi-node
      (treesit-node-check navi-node 'outdated)
    t))

(defun navi-node-hash (node)
  (list (- (treesit-node-start node)
           (treesit-node-end node))
        (treesit-node-type node)))

(defun navi-node-hash-get (hash nodes &optional default)
  (let ((found nil)
        (node))
    (while (and (setq node (pop nodes))
                (not found))
      (when (equal hash (navi-node-hash node))
        (setq found node)))
    (or found default)))

(defun navi-node-hash-at (hash point)
  (navi-node-hash-get hash (navi-nodes-at point)))

(defun navi-kill-node ()
  (interactive)
  ;; TODO
  (let ((node navi-node))
    (if (treesit-node-prev-sibling node)
        (navi-navigate-backward)
      (navi-navigate-forward))
    (kill-region (treesit-node-start node)
                 (treesit-node-end node))
    (navi-set-node-top)))

(defun navi-node-stringify ()
  (interactive)
  (let* ((start (treesit-node-start navi-node))
         (end (treesit-node-end navi-node))
         (region-content (buffer-substring-no-properties start end)))
    (replace-region-contents start end (lambda () (prin1-to-string region-content)))
    (navi-set-node-top)))

(defun navi-set-node (node)
  (interactive)
  (setq navi-node node)
  (goto-char (treesit-node-start node))
  (navi-set-position)
  (navi-visual-mark-node)
  node)

(defun navi-set-node-top ()
  (interactive)
  (navi-set-node (car (last (navi-nodes-at (point))))))

(defun navi-navigate-flow ()
  (interactive)
  (when-let ((node (or (navi-node-travel navi-node 'down)
                       (navi-node-travel navi-node 'forward)
                       (navi-node-travel navi-node 'up 'forward))))
    (navi-set-node node)))


(defun navi-navigate-flow-up ()
  (interactive)
  (when-let ((node (or (navi-node-travel navi-node 'backward)
                       (navi-node-travel navi-node 'up))))
    (navi-set-node node)))

(defun navi-navigate-forward ()
  (interactive)
  (when-let ((node (navi-node-travel navi-node 'forward)))
    (navi-set-node node)))

(defun navi-navigate-backward ()
  (interactive)
  (when-let ((node (navi-node-travel navi-node 'backward)))
    (navi-set-node node)))

(defun navi-navigate-up ()
  (interactive)
  (when-let ((node (navi-node-travel navi-node 'up)))
    (navi-set-node node)))

(defun navi-navigate-down ()
  (interactive)
  (when-let ((node (navi-node-travel navi-node 'down)))
    (navi-set-node node)))

(defun navi-different ()
  (interactive)
  (if (= (point) (treesit-node-start navi-node))
      (setq navi-position 'end)
    (setq navi-position 'start))
  (navi-set-position))

(defun navi-set-position ()
  (if (equal navi-position 'start)
      (goto-char (treesit-node-start navi-node))
    (goto-char (treesit-node-end navi-node))))

(defun navi-eval ()
  (interactive)
  (let ((eval-func (intern (format "navi-eval:%s" (navi-get-major-mode)))))
    (if (fboundp eval-func)
        (funcall eval-func
                 (buffer-substring-no-properties
                  (treesit-node-start navi-node)
                  (treesit-node-end navi-node)))
      (message "No eval function for %s" (navi-get-major-mode)))))

(defun navi-back-to-indentation ()
  (interactive)
  (back-to-indentation)
  (evil-navi-state))

(defun navi-eval-top ()
  (interactive)
  (save-mark-and-excursion
    (navi-navigate-up)
    (navi-eval)))

(defun navi-start-visual (start end)
  (when navi-visual-overlay
    (delete-overlay navi-visual-overlay))
  (setq navi-visual-overlay (make-overlay start end))
  (overlay-put navi-visual-overlay 'face 'navi-highlight))

(defun navi-node-descendants (node)
  "Collect all children of NODE and their children without using recursion."
  (let ((stack (list node))
        (descendants '()))
    (while stack
      (let ((current-node (pop stack)))
        (setq descendants (append descendants (treesit-node-children current-node)))
        (setq stack (append stack (treesit-node-children current-node)))))
    descendants))


(defun navi-avy ()
  (interactive)
  (let* ((nodes (navi-node-descendants navi-node))
         (nodes (cl-remove-if (lambda (node)
                                (when-let ((entry (alist-get (treesit-node-type node) (plist-get (navi-rules) :avy) nil nil 'string=)))
                                  (or (and (plist-get entry :pred)
                                           (plist-get entry :ignore)
                                           (funcall (plist-get entry :pred) node))
                                      (and (plist-get entry :ignore)
                                           (not (plist-get entry :pred)))))) nodes))
         (avy-result
          (avy-with navi-avy
            (avy-process
             (cl-remove-duplicates
              (mapcar 'treesit-node-start nodes)))))
         (node (cl-find-if (lambda (node) (= (treesit-node-start node) avy-result)) nodes)))
    (navi-set-node node)
    node))

(defun navi-node-space-between (node1 node2)
  (let ((node1-start (treesit-node-start node1))
        (node1-end (treesit-node-end node1))
        (node2-start (treesit-node-start node2))
        (node2-end (treesit-node-end node2)))
    (if (< (treesit-node-start node1)
           (treesit-node-start node2))
        (- node2-start node1-end)
      (- node1-start node2-end))))

(defun navi-avy-delete ()
  (interactive)
  (if (navi-node-descendants navi-node)
      (when (navi-avy)
        (kill-region (treesit-node-start navi-node)
                     (treesit-node-end navi-node))
        (evil-insert-state))
    (progn
      (kill-region (treesit-node-start navi-node)
                   (treesit-node-end navi-node))
      (evil-insert-state))))

(defun navi-visual-mark-node ()
  (interactive)
  (when (not (navi-outdated-p))
    (navi-start-visual
     (treesit-node-start navi-node)
     (treesit-node-end navi-node))))

(defun navi-yank-node ()
  (interactive)
  (let ((node navi-node))
    (when node
      (copy-region-as-kill
       (treesit-node-start node)
       (treesit-node-end node)))))

(defun navi-paste-down ()
  (interactive)
  ;; TODO
  )

(defun navi-paste-up ()
  (interactive)
  ;; TODO
  )

(defun navi-comment-node ()
  (interactive)
  (let* ((start (treesit-node-start navi-node))
         (end (treesit-node-end navi-node))
         (_ (or (navi-navigate-backward)
                (navi-navigate-forward)
                (navi-navigate-up)))
         (hash (navi-node-hash navi-node)))
    (comment-region start end)
    (navi-set-node
     (navi-node-hash-at hash (point)))))

(defun navi-next-node (node direction)
  (cl-case direction
    (forward (treesit-node-next-sibling node))
    (backward (treesit-node-prev-sibling node))
    (up (treesit-node-parent node))
    (down (treesit-node-child node 0))))


(defun navi-next-shift-node (node direction)
  (cl-case direction
    (forward (treesit-node-child node 0))
    (backward (treesit-node-parent node))
    (up (treesit-node-prev-sibling node))
    (down (treesit-node-next-sibling node))))

(defun navi-node-travel-1 (current-node direction)
  (let* ((next-node (navi-next-node current-node direction))
         (node-type (treesit-node-type next-node))
         (current-mode-key-list (plist-get (navi-rules) :navigation))
         (current-mode-key-node-f (alist-get node-type current-mode-key-list nil nil 'string=))
         (pred (or (plist-get current-mode-key-node-f :pred) 'ignore))
         (action (plist-get current-mode-key-node-f :action))
         (ignore (plist-get current-mode-key-node-f :ignore)))
    (when (not ignore)
     (if (funcall pred next-node)
         (funcall action next-node direction)
       next-node))))

(defun navi-node-travel (current-node &rest directions)
  (interactive)
  (cl-reduce
   (lambda (node direction)
     (navi-node-travel-1 node direction))
   directions
   :initial-value current-node))

(defun navi-nodes-at (point)
  (let* ((node (treesit-node-at point))
         (nodes (list node))
         (done nil))
    (while (not done)
      (let* ((node (car (last nodes)))
             (parent (treesit-node-parent node))
             (parent-start (treesit-node-start parent))
             (node-start (treesit-node-start node)))
        (if (equal parent-start node-start)
            (setq nodes (append nodes (list parent)))
          (setq done t))))
    nodes))

(defun navi-node-swap (node1 node2)
  (interactive)
  ;; TODO use marks
  (let* ((reversed (> (treesit-node-start node1) (treesit-node-start node2)))
         (upper-node (if reversed node2 node1))
         (lower-node (if reversed node1 node2))
         (temp-buffer (generate-new-buffer " *navi-temp*"))
         (c (current-buffer)))
    (let ((result
           (with-current-buffer temp-buffer
             (insert-buffer-substring c)
             (let* ((upper-node-start (treesit-node-start upper-node))
                    (upper-node-end (treesit-node-end upper-node))
                    (lower-node-start (treesit-node-start lower-node))
                    (lower-node-end (treesit-node-end lower-node))
	            (upper-node-substring (buffer-substring upper-node-start upper-node-end))
                    (lower-node-substring (buffer-substring lower-node-start lower-node-end)))
               (delete-region lower-node-start lower-node-end)
               (goto-char lower-node-start)
               (insert upper-node-substring)
               (delete-region upper-node-start upper-node-end)
               (goto-char upper-node-start)
               (insert lower-node-substring)
               (let ((new-node1-point
                      (- lower-node-start
                         (- (length upper-node-substring)
                            (length lower-node-substring))))
                     (new-node2-point upper-node-start))
                 (if reversed
                     (reverse (list new-node1-point new-node2-point))
                   (list new-node1-point new-node2-point)))))))
      (replace-buffer-contents temp-buffer)
      result)))

(defun navi-drag-up ()
  (interactive)
  (let ((next-node
         (navi-node-travel navi-node 'backward)))
    (when (and (navi-p)
               next-node
               (not (navi-node-descendant? next-node navi-node))
               (not (navi-node-descendant? navi-node next-node)))
      (let* ((hash (navi-node-hash navi-node))
             (new-points (navi-node-swap navi-node next-node)))
        (navi-set-node
         (navi-node-hash-get hash (navi-nodes-at (car new-points))
                             (treesit-node-at (car new-points))))))))

(defun navi-drag-down ()
  (interactive)
  (let ((next-node
         (navi-node-travel navi-node 'forward)))
    (when (and (navi-p)
               next-node
               (not (navi-node-descendant? next-node navi-node))
               (not (navi-node-descendant? navi-node next-node)))
      (let* ((hash (navi-node-hash navi-node))
             (new-points (navi-node-swap navi-node next-node)))
        (navi-set-node
         (navi-node-hash-get hash
                             (navi-nodes-at (car new-points))
                             (treesit-node-at (car new-points))))))))

(defun navi-node-descendant? (node1 node2)
  (member node2 (navi-node-descendants node1)))

(defcustom navi-children-wip:ruby-ts-mode
  '(("class" . (:action foo ))
    ("module" . (:action foo)))
  ""
  :type '()
  :group 'navi)

(evil-define-key nil evil-navi-state-map
  (kbd "<escape>") 'evil-normal-state
  (kbd "]") 'navi-yoink-forward
  (kbd "[") 'navi-yeet-forward
  (kbd "@") nil
  (kbd "q") nil
  (kbd "Q") nil
  (kbd "w") 'navi-drag-up
  (kbd "e") 'navi-eval
  (kbd "E") nil
  (kbd "r") nil ;; special-lispy-raise
  (kbd "R") nil ;; special-lispy-raise-some
  (kbd "t") nil ;; Teleport one day
  (kbd "T") nil ;; Teleport transfer one day
  (kbd "y") 'navi-yank-node
  (kbd "Y") nil ;; Free
  (kbd "u") 'undo-tree-undo
  (kbd "U") 'undo-tree-redo
  (kbd "i") 'evil-insert-state
  (kbd "I") 'evil-insert-line
  (kbd "o") 'evil-open-below
  (kbd "O") 'evil-open-above
  (kbd "p") 'navi-paste-down
  (kbd "P") 'navi-paste-up
  (kbd "a") 'navi-avy
  (kbd "A") 'navi-avy-delete
  (kbd "s") 'navi-drag-down
  (kbd "S") 'navi-node-stringify
  (kbd "d") 'navi-different
  (kbd "D") nil ;; idk
  (kbd "f") nil
  (kbd "F") nil
  (kbd "g") 'pop-global-mark
  (kbd "G") nil
  (kbd "h") 'navi-navigate-up
  (kbd "H") 'navi-navigate-parent
  (kbd "j") 'navi-navigate-forward
  (kbd "J") nil ;; Free
  (kbd "k") 'navi-navigate-backward
  (kbd "K") nil ;; Free
  (kbd "l") 'navi-navigate-down
  (kbd "L") 'navi-navigate-child
  (kbd ";") 'navi-comment-node
  (kbd ":") nil  ;; Free
  (kbd "'") nil  ;; Free
  (kbd "\"") nil ;; Free
  (kbd "/") nil  ;; Free
  (kbd "z") nil  ;; Free
  (kbd "Z") nil  ;; Free
  (kbd "x") 'navi-kill-node
  (kbd "X") nil ;; Free
  (kbd "c") nil ;; Clone
  (kbd "C") nil ;; Convolute, but how?
  (kbd "v") 'elpy-goto-definition
  (kbd "V") 'elpy-goto-definition-other-window
  (kbd "b") 'evil-backward-word-begin
  (kbd "B") 'evil-backward-WORD-begin
  (kbd "n") 'navi-navigate-flow
  (kbd "N") 'navi-navigate-flow-up
  (kbd "m") 'navi-format-block
  (kbd "M") nil
  (kbd ",") nil ;; Free
  (kbd "<") nil ;; Slurp back?
  (kbd ".") 'evil-repeat
  (kbd ">") nil ;; barf back?
  (kbd "/") nil ;; Occur
  (kbd "?") nil ;; Free
  )

;; Modes

(evil-define-state navi
  "Navi state."
  :tag " <*> "
  :message "Entering Navi mode..."
  :entry-hook (evil-navi-enter)
  :exit-hook (evil-navi-exit))

(defun evil-navi-enter ()
  (when (and (boundp 'hl-line-mode)
             hl-line-mode)
    (setq navi-hl-mode 'hl-line-mode)
    (hl-line-mode -1))
  (when (and (boundp 'global-hl-line-mode)
             global-hl-line-mode)
    (setq navi-hl-mode 'global-hl-line-mode)
    (global-hl-line-mode -1))
  (navi-set-node-top)
  (set-cursor-color "#2571ff"))

(defun evil-navi-exit ()
  (when (eq navi-hl-mode 'hl-line-mode)
    (hl-line-mode 1))
  (when (eq navi-hl-mode 'global-hl-line-mode)
    (global-hl-line-mode 1))
  (delete-overlay navi-visual-overlay)
  (set-cursor-color "#e95678"))

(defun navi-p ()
  (equal evil-state 'navi))

(defcustom navi-navigate-functions
  '(undo-tree-undo
    undo-tree-redo
    pop-global-mark
    elpy-goto-definition
    navi-navigate-next
    navi-navigate-previous
    navi-drag-up
    navi-drag-down
    navi-format-block
    navi-yoink-forward
    navi-yeet-forward
    navi-navigate-up
    navi-navigate-down
    navi-navigate-parent
    navi-navigate-child
    navi-avy
    navi-avy-delete
    navi-avy-mark
    navi-paste-down
    navi-paste-up)
  ""
  :type '()
  :group 'navi)

(defun navi-update-node-advice (&rest _)
  (when (and (navi-p)
             (navi-outdated-p))
    (navi-set-node-top)))

(defun navi-mark-if-visual-advice (&rest _)
  (when (navi-p)
    (navi-visual-mark-node)))

(dolist (func navi-navigate-functions)
  (advice-add func :after  'navi-mark-if-visual-advice)
  (advice-add func :before 'navi-update-node-advice))

(advice-add 'undo-tree-undo :after 'navi-update-node-advice)
(advice-add 'undo-tree-redo :after 'navi-update-node-advice)

(defun navi-node-name ()
  (interactive)
  (let ((node navi-node))
    (when node
      (message (treesit-node-type node)))))

#+END_SRC

#+STARTUP: showeverything

* Options

#+BEGIN_SRC emacs-lisp
(defcustom kwrooijen/snippet-directory
  (file-name-concat kwrooijen/emacs-directory "db/snippets")
  "Directory where snippets are stored."
  :type 'string
  :group 'kwrooijen)
#+END_SRC

* Yasnippet
:PROPERTIES:
:PACKAGE: yasnippet
:STRAIGHT: t
:END:

** Config :config:

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path kwrooijen/snippet-directory)
(add-to-list 'yas-snippet-dirs kwrooijen/snippet-directory)
(let ((yas-snippets-dir (expand-file-name "straight/repos/yasnippet-snippets/snippets" user-emacs-directory)))
  (add-to-list 'load-path kwrooijen/snippet-directory)
  (add-to-list 'yas-snippet-dirs kwrooijen/snippet-directory))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/yas-completing-read (templates)
  "Prompt the user to select a template from TEMPLATES and insert its yasnippet.
TEMPLATES is an alist of (DISPLAY-NAME . SNIPPET-KEY) pairs."
  (interactive)
  (let* ((template-names (mapcar #'car templates))
         (selected (completing-read "Select template: " template-names nil t)))
    (when selected
      (let ((snippet-key (cdr (assoc selected templates))))
        (if (and (featurep 'yasnippet) (yas-lookup-snippet snippet-key))
            (yas-expand-snippet (yas-lookup-snippet snippet-key))
          (error "Yasnippet not available or snippet '%s' not found" snippet-key))))))
#+END_SRC



** Hook :hook:
#+BEGIN_SRC emacs-lisp
((prog-mode . yas-minor-mode)
 (org-mode . yas-minor-mode))
#+END_SRC


** Bindings :general:

#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "i s" 'yas-insert-snippet)
#+END_SRC

* Yasnippet snippets
:PROPERTIES:
:PACKAGE: yasnippet-snippets
:STRAIGHT: t
:AFTER: yasnippet
:END:

** Jinx (spell checker)
:PROPERTIES:
:PACKAGE: jinx
:STRAIGHT: t
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(defun kwrooijen/jinx-add-word-at-point ()
  "Add the word at point to Jinx personal dictionary."
  (interactive)
  (let ((word (thing-at-point 'word t)))
    (if (not word)
        (user-error "No word at point")
      ;; Call the same save logic that jinx uses for @word
      (jinx--save-personal 'save ?@ word)
      (jinx--recheck-overlays)
      (message "Added '%s' to Jinx personal dictionary" word))))
#+END_SRC

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(jinx-languages "en_US,nl")
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
("M-$" 'jinx-correct)
("C-M-$" 'jinx-languages)

(kwrooijen/leader
 "jj" 'kwrooijen/jinx-add-word-at-point
 "tt" '(jinx-mode :which-key "Jinx mode"))
#+END_SRC

** Hook :hook:

Jinx only uses spell checking inside comments (and maybe doc
strings?). Making it safe to enable in programming modes.

#+BEGIN_SRC emacs-lisp
((prog-mode . jinx-mode)
 (org-mode . jinx-mode))
#+END_SRC

* Copilot
:PROPERTIES:
:PACKAGE: copilot
:STRAIGHT: (:host github :repo "copilot-emacs/copilot.el" :files ("dist" "*.el"))
:END:

** Hooks :hook:
#+BEGIN_SRC emacs-lisp
((prog-mode . copilot-mode))
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
(:keymaps 'copilot-completion-map
          "M-TAB" 'copilot-accept-completion-by-word
          "M-<tab>" 'copilot-accept-completion-by-word
          "<tab>" 'kwrooijen/tab
          "TAB" 'kwrooijen/tab
          "C-<tab>" 'copilot-next-completion
          "C-TAB" 'copilot-next-completion)

(:states 'insert
  "C-o" 'copilot-next-completion)

("M-O" 'copilot-mode)

(kwrooijen/leader
 "to" '(copilot-mode :which-key "Copilot"))
#+END_SRC


** Init :init:
#+BEGIN_SRC emacs-lisp
(defun kwrooijen/copilot-disable ()
  (when (bound-and-true-p copilot-mode)
    (setq-local kwrooijen/copilot-was-enabled t)
    (copilot-mode -1)))

(defun kwrooijen/copilot-maybe-enable ()
  (when (and (bound-and-true-p kwrooijen/copilot-was-enabled)
             (not (bound-and-true-p corfu--popup)))
    (setq-local kwrooijen/copilot-was-enabled nil)
    (copilot-mode +1)))
#+END_SRC


* Aidermacs
:PROPERTIES:
:PACKAGE: aidermacs
:STRAIGHT: t
:END:

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(aidermacs-show-diff-after-change nil)
(aidermacs-auto-commits nil)
(aidermacs-default-chat-mode 'code)
(aidermacs-extra-args '("--no-auto-commits"))
(aidermacs-default-model "openrouter/anthropic/claude-sonnet-4.5")
(aidermacs-weak-model "openrouter/x-ai/grok-code-fast-1")
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(define-advice aidermacs-run (:around (orig-fun &rest args) set-project-root)
  "Run aidermacs-run with default-directory set to project root."
  (let ((default-directory (kwrooijen/project-root)))
    (apply orig-fun args)))
#+END_SRC

# ** General :general:
# #+BEGIN_SRC emacs-lisp
# (kwrooijen/leader
# "a" 'aidermacs-transient-menu)
# #+END_SRC

* Eca
:PROPERTIES:
:PACKAGE:  eca
:STRAIGHT: t
:END:


* Corfu
:PROPERTIES:
:PACKAGE:  corfu
:STRAIGHT: t
:END:

** Init :init:
#+BEGIN_SRC emacs-lisp
(global-corfu-mode)
(corfu-popupinfo-mode)
(corfu-echo-mode)
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
;; Corfu face overrides handled by embellish-theme

(add-hook 'corfu-mode-hook
          (lambda ()
            (add-hook 'corfu-popup-open-hook  #'kwrooijen/copilot-disable nil t)
            (add-hook 'corfu-popup-close-hook #'kwrooijen/copilot-maybe-enable nil t)))
#+END_SRC


** Custom :custom:
#+BEGIN_SRC emacs-lisp
(corfu-auto t)
(corfu-cycle t)
(tab-always-indent 'complete)
(text-mode-ispell-word-completion nil)
(read-extended-command-predicate #'command-completion-default-include-p)
(corfu-left-margin-width 24)
(corfu-right-margin-width 24)
#+END_SRC

Don't auto select the current selection
#+BEGIN_SRC emacs-lisp
(corfu-preview-current nil)
(corfu-on-exact-match nil)
(corfu-quit-no-match 'separator)
(corfu-quit-at-boundary t)
#+END_SRC


** General :general:
#+BEGIN_SRC emacs-lisp
(:keymaps 'corfu-map
  "C-f" #'corfu-scroll-up
  "C-b" #'corfu-scroll-down)
#+END_SRC

* Cape
:PROPERTIES:
:PACKAGE:  cape
:STRAIGHT: t
:END:

** General :general:
#+BEGIN_SRC emacs-lisp
("M-e" cape-prefix-map)
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(add-hook 'completion-at-point-functions #'cape-dabbrev)
(add-hook 'completion-at-point-functions #'cape-file)
(add-hook 'completion-at-point-functions #'cape-elisp-block)

#+END_SRC

* Flymake
:PROPERTIES:
:PACKAGE:  flymake
:END:

** General :general:
#+BEGIN_SRC emacs-lisp
(:keymaps 'prog-mode-map
"M-n" #'flymake-goto-next-error
"M-p" #'flymake-goto-prev-error)
#+END_SRC

** Custom :custom:
Don't show indicator. NOTE: This causes the marker (exclamation mark)
to be displayed inside of the buffer, instead of the margin /
fringe. To hotfix this, go to the `flymake--highlight-line` function
and replace `"!"` with `""`. As of now there is no variable we can
adjust to fix this.
#+BEGIN_SRC emacs-lisp
(flymake-indicator-type nil)
(flymake-indicator-function #'ignore)
#+END_SRC

* Eglot
:PROPERTIES:
:PACKAGE:  eglot
:END:

* Winum
:PROPERTIES:
:PACKAGE: winum
:STRAIGHT: t
:DEMAND: t
:END:

Number your open windows and switch between them.

** Custom :custom:

Don't add window number to modeline

#+BEGIN_SRC emacs-lisp
(winum-auto-setup-mode-line nil)
#+END_SRC

** Config :config:

#+BEGIN_SRC emacs-lisp
(winum-mode)
#+END_SRC

** Bindings :general:

#+BEGIN_SRC emacs-lisp
("M-1" 'winum-select-window-1)
("M-2" 'winum-select-window-2)
("M-3" 'winum-select-window-3)
("M-4" 'winum-select-window-4)
("M-5" 'winum-select-window-5)
("M-6" 'winum-select-window-6)
("M-7" 'winum-select-window-7)
("M-8" 'winum-select-window-8)
("M-9" 'winum-select-window-9)
#+END_SRC

* Winner
:PROPERTIES:
:PACKAGE: winner
:STRAIGHT: t
:END:

Undo or redo changes in your window layout.

** Init :init:

#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "w u" '(winner-undo :which-key "Undo window layout")
  "w U" '(winner-redo :which-key "Redo window layout"))
#+END_SRC

* Popwin
:PROPERTIES:
:PACKAGE: popwin
:STRAIGHT: t
:END:

Manage windows that pop up on your screen.

** Init :init:

#+BEGIN_SRC emacs-lisp
(popwin-mode 1)
#+END_SRC

** Config :config:

#+BEGIN_SRC emacs-lisp
(push '("*eval*" :height 10 :dedicated t) popwin:special-display-config)
(push '("*shell*" :height 20 :position bottom :stick t) popwin:special-display-config)
(push '("\\*vterm.*\\*" :height 30 :position bottom :stick t :regexp t) popwin:special-display-config)
(push '("*Bebop Interceptor*" :height 40 :dedicated t) popwin:special-display-config)
(push '(minitest-compilation-mode :width 0.5 :position right :noselect t :stick t) popwin:special-display-config)
(push '("*eshell*"           :height 15 :position bottom :stick t) popwin:special-display-config)
(push '("^.*\\-eshell\\*.*$" :height 15 :position bottom :stick t :regexp t) popwin:special-display-config)
(push '("^.**Agenda Commands*" :height 15 :position bottom :stick t) popwin:special-display-config)
(push '("\\*edit-indirect .*\\*" :height 0.4 :position bottom :stick t :noselect t :regexp t) popwin:special-display-config)
#+END_SRC

#+STARTUP: showeverthing

* Clojure
:PROPERTIES:
:PACKAGE: clojure-mode
:STRAIGHT: t
:END:

** Hook :hook:

#+BEGIN_SRC emacs-lisp
((clojure-mode . cider-mode)
 (clojure-mode . lispy-mode)
 (clojure-mode . clj-refactor-mode)
 (clojure-mode . flymake-mode))
#+END_SRC

** Custom :custom:

#+BEGIN_SRC emacs-lisp
(clojure-indent-style 'always-align)
(clojure-align-forms-automatically t)
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
(:keymaps '(clojure-mode-map clojurescript-mode-map)
          "M-e" 'cider-pprint-eval-sexp)
#+END_SRC

* Clojure refactor
:PROPERTIES:
:PACKAGE: clj-refactor
:STRAIGHT: t
:AFTER: clojure
:END:

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(cljr-warn-on-eval nil)
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/local-leader
 :keymaps '(clojure-mode-map clojurescript-mode-map)
            :states 'normal
            "r t f" 'cljr-thread-first-all
            "r t l" 'cljr-thread-last-all)
#+END_SRC


* Cider
:PROPERTIES:
:PACKAGE: cider
:STRAIGHT: t
:END:

** Custom :custom:

This setting enables dynamic cljs completions.
That is, expressions at point are evaluated and the properties of the
resulting value are used to compute completions.

#+BEGIN_SRC emacs-lisp
(cider-enhanced-cljs-completion-p nil)
#+END_SRC

When non-nil a bit of help text will be displayed on REPL start.

#+BEGIN_SRC emacs-lisp
(cider-repl-display-help-banner nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(cider-repl-display-help-banner nil)
(cider-figwheel-main-default-options "dev")
(cider-default-cljs-repl 'figwheel-main)
(cider-preferred-build-tool 'clojure-cli)
(cider-shadow-default-options "app")
#+END_SRC

** Init :init:
#+BEGIN_SRC emacs-lisp
(add-to-list 'safe-local-variable-values '(cider-default-cljs-repl . shadow))
(add-to-list 'safe-local-variable-values '(cider-shadow-default-options . "app"))
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/local-leader
  :keymaps '(clojure-mode-map clojurescript-mode-map)
            :states 'normal
            "r j" 'cider-jack-in-clj
            "r c" 'cider-connect-clj
            "s j n" 'cider-jack-in-clj&cljs
            "s j k" 'kwrooijen/cider-kill-all
            "b b" 'cider-switch-to-repl-buffer
            "e b" 'cider-eval-buffer)
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(defun kwrooijen/cider-kill-all ()
  "Kill all CIDER-related buffers (REPLs, error buffers, connection buffers, etc.).
Prompts for confirmation only once when called interactively."
  (interactive)
  (let ((cider-buffers
         (seq-filter
          (lambda (buf)
            (string-prefix-p "*cider" (buffer-name buf)))
          (buffer-list))))
    (when cider-buffers
      (when (or (not (called-interactively-p 'interactive))
                (yes-or-no-p (format "Kill %d CIDER buffers? " (length cider-buffers))))
        ;; Suppress ONLY the per-buffer process-kill prompts
        (let ((kill-buffer-query-functions
               (remq 'process-kill-buffer-query-function kill-buffer-query-functions)))
          (mapc #'kill-buffer cider-buffers))
        (message "Killed %d CIDER buffers." (length cider-buffers))))))
#+END_SRC

Dockerfile
:PROPERTIES:
:PACKAGE: dockerfile-mode
:STRAIGHT: t
:END:

* Emacs lisp
:PROPERTIES:
:PACKAGE: emacs-lisp
:END:

** Hook :hook:
#+BEGIN_SRC emacs-lisp
(emacs-lisp-mode . lispy-mode)
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/local-leader
  :keymaps 'emacs-lisp-mode-map
  :states 'normal
  "e b" 'eval-buffer
  "r t f" 'cljr-thread-first-all
  "r t l" 'cljr-thread-last-all)
#+END_SRC

* Go
:PROPERTIES:
:PACKAGE: go-mode
:STRAIGHT: t
:END:

** Hook :hook:
#+BEGIN_SRC emacs-lisp
((before-save . gofmt-before-save))
#+END_SRC

* Javascript
:PROPERTIES:
:PACKAGE: js2-mode
:STRAIGHT: t
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
(setq-default js2-strict-missing-semi-warning nil)
(setq-default js2-basic-offset 2)
#+END_SRC

* Json
:PROPERTIES:
:PACKAGE: json-mode
:STRAIGHT: t
:END:

#+BEGIN_SRC emacs-lisp

(defun kwrooijen/paperspace-set-notebook-session (url)
  "Update the Jupyter session and token based on the provided URL."
  (interactive "sEnter the Paperspace Jupyter Kernel URL: ")
  (let* ((url-components (url-generic-parse-url url))
         (host (url-host url-components))
         (token (url-filename url-components))
         (token-value (replace-regexp-in-string "^\\?token=" "" token))
         (session (concat host "#0:jupyter")))
    (setq jupyter-rest-api-default-token token-value)
    (save-excursion
      (goto-char (point-min))
      (if (re-search-forward "^#\\+PROPERTY: header-args:python" nil t)
          (progn
            (beginning-of-line)
            (kill-line)
            (insert (concat "#+PROPERTY: header-args:python :session /jpys:" session " :pandoc t")))
        ;; If the property doesn't exist, insert it at the beginning of the buffer
        (goto-char (point-min))
        (insert (concat "#+PROPERTY: header-args:python :session /jpys:" session " :pandoc t\n"))))
    (org-mode-restart)
    (message "Session set to: %s and token set to: %s" session token-value)))

(use-package ox-ipynb
  :straight (:host github :repo "jkitchin/ox-ipynb" :files ("dist" "*.el")))

(use-package jupyter
  :straight t
  :general
  (kwrooijen/local-leader
    :keymaps 'org-mode-map
    :states 'normal
    ";" 'kwrooijen/jupyter-color-fix)

  :hook (org-mode . kwrooijen/jupyter-setup)
  :config

  (defun kwrooijen/jupyter-setup ()
    (interactive)
    (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
    (add-hook 'org-babel-after-execute-hook 'kwrooijen/jupyter-color-fix))

  (defun kwrooijen/jupyter-color-fix (&rest _)
    (interactive)
    (org-babel-jupyter-override-src-block "python")
    (jupyter-ansi-color-apply-on-region (point-min) (point-max)))

  (require 'ob-jupyter)
  (require 'ob-shell)
  (setq-local org-image-actual-width 1024))

(use-package org
  :init
  (add-to-list 'org-babel-load-languages '(python . t))
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)
     (jupyter . t)))
  (add-to-list 'org-src-lang-modes '("python" . python-ts))
  (when (not (boundp 'org-babel-default-header-args:python))
    (setq org-babel-default-header-args:python nil))
  (add-to-list 'org-babel-default-header-args:python '(:session . "*Python*")))
#+END_SRC

* Markdown
:PROPERTIES:
:PACKAGE: markdown-mode
:STRAIGHT: t
:END:

Install Poetry + Pyright

#+BEGIN_SRC shell
brew install poetry pyright
#+END_SRC

Add in-project to your global poetry config. This will make it easier
for pyright to find your dependencies

#+BEGIN_QUOTE ~/Library/Application\ Support/pypoetry/config.toml
[virtualenvs]
in-project = true
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(when (and (fboundp 'python-ts-mode)
           (treesit-available-p))
  (add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode)))
#+END_SRC


* Python
:PROPERTIES:
:PACKAGE: python
:END:

** Init :init:
#+BEGIN_SRC emacs-lisp
(require 'eglot)
(setenv "PYTHONIOENCODING" "utf8")
(define-key python-base-mode-map (kbd "M-n") 'evil-collection-unimpaired-next-error)
(define-key python-base-mode-map (kbd "M-p") 'evil-collection-unimpaired-previous-error)
#+END_SRC


** Config :config:
#+BEGIN_SRC emacs-lisp
(add-to-list 'eglot-server-programs
             `(python-base-mode . ("pyright-langserver" "--stdio")))

(defun kwrooijen/python-combobulate-shell-send-block ()
  (interactive)
  (save-excursion
    (let ((start (treesit-node-start kwrooijen/combobulate-current-node ))
          (end (treesit-node-end kwrooijen/combobulate-current-node )))
      (python-shell-send-region start end))))

(defun kwrooijen/python-find-import-position (module)
  (save-excursion
    (goto-char (point-min))
    (let* ((import-regex (format "^from %s import.*" (regexp-quote module)))
           (case-fold-search nil)
           (import-position nil))
      (while (re-search-forward import-regex nil t)
        (setq import-position (point)))
      import-position)))

(defun kwrooijen/python-add-or-update-import (module class-name)
  "Add or update an import statement for CLASS-NAME from MODULE in the current Python buffer.
If MODULE is already imported, append CLASS-NAME to the existing import.
Otherwise, add a new import statement after existing imports."
  (save-excursion
    (goto-char (point-min))
    (let ((case-fold-search nil)
          (import-position (kwrooijen/python-find-import-position module)))
      (if import-position
          (progn
            (goto-char import-position)
            (let ((current-line (buffer-substring-no-properties (line-beginning-position) (line-end-position))))
              (if (string-match-p (format "\\<%s\\>" (regexp-quote class-name)) current-line)
                  (message "Class name %s already exists in the current line." class-name)
                (progn
                  (goto-char (line-end-position))
                  (insert ", " class-name)))))
       (progn
         (while (re-search-forward "^\\(from\\|import\\) " nil t))
         (forward-line 1)
         (insert (format "from %s import %s" module class-name))
         (newline))))))

(defun kwrooijen/run-python-project ()
  (interactive)
  (let ((current-window (selected-window))
        (default-directory (kwrooijen/project-root)))
    (run-python nil t t)
    (select-window current-window 'norecord)))
#+END_SRC

#+BEGIN_SRC emacs-lisp

(defun kwrooijen/langchain-select-template ()
  "Prompt the user to select a LangChain template and insert its yasnippet."
  (interactive)
  (kwrooijen/yas-completing-read
   '(("AIMessagePromptTemplate" . "aimessageprompttemplate")
     ("BaseChatPromptTemplate" . "basechatprompttemplate")
     ("BaseMessagePromptTemplate" . "basemessageprompttemplate")
     ("BasePromptTemplate" . "baseprompttemplate")
     ("BaseStringMessagePromptTemplate" . "basestringmessageprompttemplate")
     ("ChatMessagePromptTemplate" . "chatmessageprompttemplate")
     ("ChatPromptTemplate" . "chatprompttemplate")
     ("DictPromptTemplate" . "dictprompttemplate")
     ("FewShotChatMessagePromptTemplate" . "fewshotchatmessageprompttemplate")
     ("FewShotPromptTemplate" . "fewshotprompttemplate")
     ("FewShotPromptWithTemplates" . "fewshotpromptwithtemplates")
     ("HumanMessagePromptTemplate" . "humanmessageprompttemplate")
     ("ImagePromptTemplate" . "imageprompttemplate")
     ("PromptTemplate" . "prompttemplate")
     ("StringPromptTemplate" . "stringprompttemplate")
     ("SystemMessagePromptTemplate" . "systemmessageprompttemplate"))))
#+END_SRC


** Hook :hook:
#+BEGIN_SRC emacs-lisp
((python-base-mode . eglot-ensure)
 (python-base-mode . electric-indent-mode)
 (python-base-mode . kwrooijen/python-get-cached-modules))
#+END_SRC


** Custom :custom:
#+BEGIN_SRC emacs-lisp
(python-shell-completion-native-enable nil)
(python-indent-guess-indent-offset-verbose nil)
(python-indent 4)
(py-indent-offset 4)
(python-indent-offset 4)
#+END_SRC

** General :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/local-leader
  :keymaps 'python-base-mode-map
  :states '(normal visual)
  "p" '(:ignore t :which-key "Project")
  "p w" 'kwrooijen/python-workon-project-venv
  "e" '(:ignore t :which-key "Eval")
  "e f" 'python-shell-send-file
  "e d" 'python-shell-send-defun
  "e o" 'python-shell-send-block
  "e e" 'kwrooijen/python-shell-send-block
  "e s" 'python-shell-send-string
  "e r" 'python-shell-send-region
  "e b" 'python-shell-send-buffer
  "e s" 'python-shell-send-statement
  "i" '(:ignore t :which-key "Import")
  "i i" 'kwrooijen/python-import-statement
  "i s" 'kwrooijen/python-add-import-line-to-extras
  "i b" 'kwrooijen/python-build-cache
  "i t" 'kwrooijen/langchain-select-template
  "h" '(:ignore t :which-key "Help")
  "h b" 'eldoc-doc-buffer
  "h d" 'eglot-find-declaration
  "r" '(:ignore t :which-key "Refactor")
  "r f" '(python-black-buffer :which-key "Format buffer")
  "b" '(:ignore t :which-key "Buffer")
  "b b" 'python-shell-switch-to-shell
  "'" '(kwrooijen/run-python-project :which-key "REPL"))
#+END_SRC




* Poetry
:PROPERTIES:
:PACKAGE: poetry
:STRAIGHT: t
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(defvar kwrooijen/python-cache-path
  (file-name-concat kwrooijen/emacs-directory "db/python_module_cache.json")
  "Path to the JSON file storing the Python module cache.")

(defvar kwrooijen/python-extra-modules-path
  (file-name-concat kwrooijen/emacs-directory "db/kwrooijen-python-extra-modules.list")
  "Path to the file storing kwrooijen/python-extra-modules.")

(defvar kwrooijen/python-venv-dir nil
  "Path to the Python virtual environment directory.")

(defvar kwrooijen/python-cache nil
  "In-memory cache of module mappings.")

(defun kwrooijen/python-get-venv-dir ()
  (setq kwrooijen/python-venv-dir
        (s-trim (shell-command-to-string "python -c 'import sys; print(sys.prefix)'"))))

(defun kwrooijen/python-load-cache ()
  "Load the cache from kwrooijen/python-cache-path if valid.
Returns nil if the cache is invalid or doesn't exist."
  (when (file-exists-p kwrooijen/python-cache-path)
    (with-temp-buffer
      (insert-file-contents kwrooijen/python-cache-path)
      (setq kwrooijen/python-cache
            (json-read-from-string (buffer-string))))))

(defun kwrooijen/python-get-cached-modules ()
  "Return the cached module mappings, rebuilding if necessary."
  (unless kwrooijen/python-cache
    (setq kwrooijen/python-cache (kwrooijen/python-load-cache)))
  kwrooijen/python-cache)

(defun kwrooijen/python-find-class-or-function (name)
  "Search for Python modules defining or exporting NAME using the cache.
Also check kwrooijen/python-extra-modules."
  (interactive "sModule name: ")
  (let* ((cached-modules (kwrooijen/python-get-cached-modules))
         (matching-modules (alist-get name cached-modules nil nil #'string=))
         ;; Convert matching-modules obarray to list
         (matching-modules (append matching-modules '())))
    (if matching-modules
        (sort matching-modules #'string<)
      (message "No modules found defining or exporting %s." name)
      nil)))

(defun kwrooijen/python-add-or-update-import (module class-name)
  "Add or update an import statement for CLASS-NAME from MODULE in the current buffer."
  (save-excursion
    (goto-char (point-min))
    (if (re-search-forward (format "^from %s import " (regexp-quote module)) nil t)
        (let ((existing-imports (buffer-substring-no-properties (point) (line-end-position))))
          (unless (string-match-p (format "\\b%s\\b" class-name) existing-imports)
            (end-of-line)
            (insert (format ", %s" class-name))))
      (progn
        (goto-char (point-min))
        (insert (format "from %s import %s\n" module class-name))))))

(defun kwrooijen/python-import-statement (class-name)
  "Prompt for a module exporting CLASS-NAME and add/update an import statement.
Uses cached module data for faster lookup. If only one module is found,
select it automatically."
  (interactive (list (or (thing-at-point 'symbol t) (read-string "Class Name: "))))
  (let* ((module-paths (kwrooijen/python-find-class-or-function class-name)))
    (if module-paths
        (let ((selected-module (if (= (length module-paths) 1)
                                   (car module-paths)
                                 (completing-read (format "Select module [%s]: " class-name) module-paths nil t))))
          (kwrooijen/python-add-or-update-import selected-module class-name))
      (message "No modules found exporting class %s. Call (kwrooijen/python-build-cache) to rebuild" class-name))))

(defvar python-script-var
  "import ast
import json
import os
import sys
from collections import defaultdict

def write_all_functions_and_classes(venv_path, output_file):
    \"\"\"
    Analyzes Python files in a .venv to map functions and classes to their modules,
    including modules that expose them via __all__ in __init__.py, and writes the
    result to a JSON file, merging with existing content if present. Excludes modules
    with names starting with '_'.

    Args:
        venv_path (str): Path to the .venv directory.
        output_file (str): Path to the JSON output file.
    \"\"\"
    result = defaultdict(list)

    # Ensure the venv path is valid
    if not os.path.isdir(venv_path):
        return

    # Scan the venv directory for function and class definitions
    for root, _, files in os.walk(venv_path):
        for file in files:
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        source = f.read()

                    # Parse the source code into an AST
                    tree = ast.parse(source, filename=file_path)

                    # Calculate the module path
                    relative_path = os.path.relpath(root, venv_path)
                    module_parts = relative_path.split(os.sep)

                    # Remove 'lib', 'pythonX.Y', 'site-packages' from the path
                    try:
                        site_packages_idx = module_parts.index('site-packages')
                        module_parts = module_parts[site_packages_idx + 1:]
                    except ValueError:
                        pass

                    # Skip if any module part starts with '_'
                    if any(part.startswith('_') for part in module_parts if part):
                        continue

                    if any(part.startswith('src') for part in module_parts if part):
                        continue

                    # Handle __init__.py and regular .py files
                    if file == '__init__.py':
                        module_path = '.'.join(part for part in module_parts if part)
                    else:
                        module_name = os.path.splitext(file)[0]
                        # Skip if the module name starts with '_'
                        if module_name.startswith('_'):
                            continue
                        if module_name.startswith('src.'):
                            continue
                        module_parts.append(module_name)
                        module_path = '.'.join(part for part in module_parts if part)

                    # Collect function and class definitions
                    for node in ast.walk(tree):
                        if isinstance(node, ast.FunctionDef):
                            result[node.name].append(module_path)
                        elif isinstance(node, ast.ClassDef):
                            result[node.name].append(module_path)

                    # For __init__.py, check for __all__ and map listed names
                    if file == '__init__.py':
                        for node in ast.walk(tree):
                            if (isinstance(node, ast.Assign) and
                                len(node.targets) == 1 and
                                isinstance(node.targets[0], ast.Name) and
                                node.targets[0].id == '__all__'):
                                if isinstance(node.value, ast.List):
                                    for elt in node.value.elts:
                                        if isinstance(elt, ast.Str) or (
                                            isinstance(elt, ast.Constant) and isinstance(elt.value, str)
                                        ):
                                            # Map string in __all__ to this module
                                            name = elt.s if hasattr(elt, 's') else elt.value
                                            result[name].append(module_path)

                except (SyntaxError, UnicodeDecodeError):
                    continue

    # Convert defaultdict to regular dict and remove duplicates
    new_result = {k: list(set(v)) for k, v in result.items()}

    # Load existing results if output_file exists
    merged_result = new_result.copy()
    if os.path.exists(output_file):
        try:
            with open(output_file, 'r', encoding='utf-8') as f:
                existing_result = json.load(f)

            # Merge existing and new results, combining module lists as sets
            for name, modules in existing_result.items():
                if name in merged_result:
                    # Combine module lists and remove duplicates
                    merged_result[name] = list(set(merged_result[name] + modules))
                else:
                    # Add new name and its modules
                    merged_result[name] = modules
        except (json.JSONDecodeError, IOError):
            # If file is corrupt or unreadable, proceed with new_result
            pass

    # Write merged result to output_file
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(merged_result, f, indent=2, ensure_ascii=False)

if __name__ == \"__main__\":
    if len(sys.argv) != 3:
        print(\"Usage: python script.py <venv_path> <output_file>\")
        sys.exit(1)
    venv_path = sys.argv[1]
    output_file = sys.argv[2]
    write_all_functions_and_classes(venv_path, output_file)"
  "Python script to map functions and classes to their modules, stored for execution from Emacs, excluding modules with names starting with '_'.")


(defun kwrooijen/python-build-cache ()
  (interactive)
  (let ((venv-path (kwrooijen/python-get-venv-dir))
        (output-file kwrooijen/python-cache-path))
    (message "Compiling [%s]..." venv-path)
    (shell-command-to-string
     (format "python -c %s %s %s"
             (shell-quote-argument python-script-var)
             (shell-quote-argument venv-path)
             (shell-quote-argument output-file)))
    (setq kwrooijen/python-cache nil)
    (kwrooijen/python-get-cached-modules)
    (message "Done")))
#+END_SRC




* Pyvenv
:PROPERTIES:
:PACKAGE: pyvenv
:STRAIGHT: t
:END:

** Init :init:
#+BEGIN_SRC emacs-lisp
(setenv "WORKON_HOME" (expand-file-name "~/.virtualenvs/"))
#+END_SRC

** Hook :hook:
#+BEGIN_SRC emacs-lisp
(python-base-mode . kwrooijen/python-workon-project-venv)
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(defun kwrooijen/python-workon-project-venv ()
  "Activate the Python virtual environment in .venv at the project root.
If .venv exists and is not already activated, activate it using pyvenv-activate.
If the virtual environment is already activated, do nothing."
  (interactive)
  (let* ((venv-dir (when-let (project-root (kwrooijen/project-root))
                     (expand-file-name ".venv" project-root))))
    (when (and venv-dir
               (file-directory-p venv-dir)
               (or (not pyvenv-virtual-env)
                   (not (string= (directory-file-name (expand-file-name pyvenv-virtual-env))
                                 (directory-file-name (expand-file-name venv-dir))))))
      (pyvenv-activate venv-dir)
      (message "Activated virtual environment: %s" venv-dir))))
#+END_SRC


** Custom :custom:
#+BEGIN_SRC emacs-lisp
(pyvenv-post-activate-hooks
      (list (lambda ()
              (setq python-shell-interpreter (concat pyvenv-virtual-env "bin/python")))))
(pyvenv-post-deactivate-hooks
      (list (lambda ()
              (setq python-shell-interpreter "python3"))))
#+END_SRC



* Python Black
:PROPERTIES:
:PACKAGE: python-black
:STRAIGHT: t
:AFTER: python
:END:



* Eglot
:PROPERTIES:
:PACKAGE: eglot
:END:

** Init :init:
#+BEGIN_SRC emacs-lisp
(defun kwrooijen/eglot-error-at-point ()
  "Get the error message at point using Eglot."
  (interactive)
  (if (not (eglot-managed-p))
      (error "Eglot is not managing this buffer")
    (let ((diagnostics (flymake-diagnostics (point))))
      (if diagnostics
          (flymake-diagnostic-text (car diagnostics))
        (error "No error at point")))))
#+END_SRC

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(eglot-workspace-configuration
 '(:python.analysis
   (:diagnosticSeverityOverrides
    (:reportAny "none"
                :reportAssignmentIssue "error"
                :reportAssertAlwaysTrue "error"
                :reportAssertType "error"
                :reportAttributeAccessIssue "error"
                :reportCallIssue "error"
                :reportConstantRedefinition "error"
                :reportDeprecated "error"
                :reportDuplicateImport "error"
                :reportFunctionMemberAccess "error"
                :reportGeneralTypeIssues "error"
                :reportImplicitOverride "error"
                :reportImplicitStringConcatenation "error"
                :reportImportCycles "error"
                :reportIncompatibleMethodOverride "error"
                :reportIncompatibleVariableOverride "error"
                :reportIndexIssue "none"
                :reportInvalidStringEscapeSequence "error"
                :reportInvalidStubStatement "error"
                :reportMatchNotExhaustive "error"
                :reportMissingImports "error"
                :reportMissingModuleSource "error"
                :reportMissingTypeArgument "error"
                :reportMissingTypeStubs "none"
                :reportNoOverload "error"
                :reportNonPrivateAccess "error"
                :reportOptionalCall "error"
                :reportOptionalContextManager "error"
                :reportOptionalIterable "error"
                :reportOptionalMemberAccess "error"
                :reportOptionalOperand "error"
                :reportOptionalSubscript "error"
                :reportOverlappingOverload "error"
                :reportPrivateImportUsage "error"
                :reportPrivateUsage "error"
                :reportPropertyTypeMismatch "error"
                :reportProtocolMemberAccess "error"
                :reportShadowedImports "error"
                :reportTypeCommentUsage "error"
                :reportTypedDictNotRequiredAccess "error"
                :reportUnboundVariable "error"
                :reportUndefinedVariable "error"
                :reportUninitializedInstanceVariable "error"
                :reportUnknownArgumentType "none"
                :reportArgumentType "none"
                :reportUnknownLambdaType "none"
                :reportUnknownMemberType "none"
                :reportUnknownParameterType "none"
                :reportUnknownVariableType "none"
                :reportUnnecessaryCast "error"
                :reportUnnecessaryComparison "error"
                :reportUnnecessaryContains "error"
                :reportUnnecessaryIsInstance "error"
                :reportUnnecessaryTypeIgnoreComment "error"
                :reportUnreachable "error"
                :reportUnsafeMultipleInheritance "error"
                :reportUnsupportedDunderAll "error"
                :reportUnusedCallResult "none"
                :reportUnusedClass "error"
                :reportUnusedCoroutine "error"
                :reportUnusedExpression "error"
                :reportUnusedFunction "error"
                :reportUnusedImport "error"
                :reportUnusedVariable "error"
                :reportWildcardImportFromLibrary "error"))))
#+END_SRC

* Ruby Treesitter mode
:PROPERTIES:
:PACKAGE: ruby-ts-mode
:END:

** Config :config:

Custom Ruby eval function for Navi

#+BEGIN_SRC emacs-lisp
(defun navi-eval:ruby-ts-mode (code)
  (comint-send-string (inf-ruby-proc) (format "%s\n" (string-trim-right code) ))
  (save-excursion
    (forward-line 1)
    (inf-ruby--eval-overlay
     (ruby-print-result-value))))

(defun kwrooijen/ruby-eval-and-return (code)
  "Send CODE to the inferior Ruby process and return the result.
To prevent the inferior Ruby process buffer from being polluted,
we store the buffer content in a temporary buffer, send the code
to the inferior Ruby process, and then return the result. Then we
restore the inferior Ruby process buffer to its original state."
  (let ((temp-buffer (generate-new-buffer "ruby-eval")))
    (with-current-buffer (process-buffer (inf-ruby-proc))
      (copy-to-buffer temp-buffer (point-min) (point-max))
      (comint-send-string (inf-ruby-proc) (format "%s\n" (string-trim code)))
      (let ((result (ruby-print-result-value))
            (inhibit-read-only t))
        (replace-buffer-contents temp-buffer)
        (kill-buffer temp-buffer)
        result))))
#+END_SRC

Require inf ruby

#+BEGIN_SRC emacs-lisp
(require 'inf-ruby)
#+END_SRC

** Bindings :general:

#+BEGIN_SRC emacs-lisp
(:keymaps 'ruby-ts-mode-map
          "M-a" 'navi-back-to-indentation)
#+END_SRC

** Hook :hook:

#+BEGIN_SRC emacs-lisp
(ruby-ts-mode . electric-indent-mode)
#+END_SRC


* Ruby mode
:PROPERTIES:
:PACKAGE: ruby-mode
:END:

** Hook :hook:

If we enter Ruby mode, switch to ruby-ts-mode.

#+BEGIN_SRC emacs-lisp
((ruby-mode . ruby-ts-mode)
 (ruby-ts-mode . eglot-ensure))
#+END_SRC

** Init :init:

Remap ruby-mode to ruby-ts-mode to make use of Treesitter.

#+BEGIN_SRC emacs-lisp
(add-to-list 'major-mode-remap-alist '(ruby-mode . ruby-ts-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/rails-routes ()
  "Find the rails route based on a search string"
  (interactive)
  (let ((search-string (read-string "Search string: ")))
    (async-shell-command (concat "rails routes | grep " search-string))))
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "c r c" 'kwrooijen/rails-create-stimulus-controller)
#+END_SRC


* Inferior Ruby
:PROPERTIES:
:PACKAGE: inf-ruby
:STRAIGHT: t
:END:

https://github.com/nonsequitur/inf-ruby

inf-ruby provides a REPL buffer connected to a Ruby subprocess.

** Init :init:
#+BEGIN_SRC emacs-lisp
(defun kwrooijen/ruby-rdbg ()
  (interactive)
  (if (get-buffer "*rdbg*")
      (switch-to-buffer "*rdbg*")
    (inf-ruby-console-run (format "rdbg -An") "rdbg")))
#+END_SRC

** Config :config:

Start the inf ruby console at the root of the rails project

#+BEGIN_SRC emacs-lisp
(defun inf-ruby-console-rails-from-project-root ()
  (interactive)
  (inf-ruby-console-rails (kwrooijen/project-root)))
#+END_SRC

Locally remove underlines from the Inf-Ruby buffers to make it less
chaotic.

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/inf-ruby-remove-underline ()
  (face-remap-add-relative 'underline :underline nil))
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/local-leader
  :keymaps 'ruby-ts-mode-map
  :states 'normal
  "'" 'inf-ruby
  ";" 'kwrooijen/ruby-rdbg
  "r" 'inf-ruby-console-rails-from-project-root
  "i s" 'ruby-switch-to-inf
  "i j" 'ruby-send-line
  "b b" 'ruby-switch-to-inf)
#+END_SRC

** Hook :hook:
#+BEGIN_SRC emacs-lisp
(inf-ruby-mode . kwrooijen/inf-ruby-remove-underline)
(inf-ruby-mode . eglot-ensure)
#+END_SRC


# * Chruby
# :PROPERTIES:
# :PACKAGE: chruby
# :STRAIGHT: t
# :END:

# ** Hook :hook:

# #+BEGIN_SRC emacs-lisp
# (ruby-mode-hook . 'chruby-use-corresponding)
# #+END_SRC

* Rust
:PROPERTIES:
:PACKAGE: rust-mode
:STRAIGHT: t
:END:

** Bindings :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/local-leader
  :keymaps 'rust-mode-map
  :states 'normal
  "r" 'rust-run
  "t" 'rust-test
  "b" 'rust-compile)
#+END_SRC

** Custom :custom:

#+BEGIN_SRC emacs-lisp
(rust-format-on-save t)
#+END_SRC

* Web mode
:PROPERTIES:
:PACKAGE:  web-mode
:STRAIGHT: t
:END:

** Init :init:

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.css\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.scss\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.sass\\'" . web-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/web-wrap-erb-output ()
  "Wrap the current region (highlighted text) in <%= %>."
  (interactive)
  (if (use-region-p)
      (let ((beg (region-beginning))
            (end (region-end)))
        (save-excursion
          (goto-char end)
          (insert " %>")
          (goto-char beg)
          (insert "<%= ")
          (call-interactively 'evil-insert)))
    (progn
      (insert "<%=  %>")
      (backward-char 3)
      (call-interactively 'evil-insert))))

(defun kwrooijen/web-wrap-erb ()
  "Wrap the current region (highlighted text) in <% %>."
  (interactive)
  (if (use-region-p)
      (let ((beg (region-beginning))
            (end (region-end)))
        (save-excursion
          (goto-char end)
          (insert " %>")
          (goto-char beg)
          (insert "<% ")
          (call-interactively 'evil-insert)))
    (progn
      (insert "<%  %>")
      (backward-char 3)
      (call-interactively 'evil-insert))))
#+END_SRC

#+BEGIN_SRC emacs-lisp

(defun kwrooijen/web-mode-before-save-hook ()
  (interactive)
  (when (eq major-mode 'web-mode)
    ;(web-mode-buffer-indent)
))

#+END_SRC



** Custom :custom:

Basic indentation rules

#+BEGIN_SRC emacs-lisp
(web-mode-markup-indent-offset 2)
(web-mode-css-indent-offset 2)
(web-mode-code-indent-offset 2)
(web-mode-part-padding 2)
(web-mode-style-padding 2)
(web-mode-block-padding 2)
(web-mode-script-padding 2)
#+END_SRC



Highlight the tags of the current element.

#+BEGIN_SRC emacs-lisp
(web-mode-enable-current-element-highlight t)
#+END_SRC

** Hook :hook:
#+BEGIN_SRC emacs-lisp
((web-mode . electric-indent-mode)
 (web-mode . paredit-mode)
 (before-save . kwrooijen/web-mode-before-save-hook))
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/local-leader
 :keymaps '(web-mode-map)
            :states '(normal visual)
            "r r" 'kwrooijen/web-wrap-erb-output
            "r e" 'kwrooijen/web-wrap-erb)
#+END_SRC

* Emmet mode
:PROPERTIES:
:PACKAGE:  emmet-mode
:STRAIGHT: t
:END:


** Bindings :general:
#+BEGIN_SRC emacs-lisp
(:states 'insert
 :keymaps 'web-mode-map
         "C-j" 'emmet-expand-line)
#+END_SRC

** Hook :hook:
#+BEGIN_SRC emacs-lisp
((sgml-mode-hook . emmet-mode)
 (css-mode-hook . emmet-mode))
#+END_SRC

* Yaml
:PROPERTIES:
:PACKAGE: yaml-mode
:STRAIGHT: t
:END:

** Mode line faces

#+BEGIN_SRC emacs-lisp
(defface kwrooijen/modeline-border
  `((t (:foreground ,(face-attribute 'embellish-theme-foreground-fg-face :foreground)))
    (t (:background ,(face-attribute 'embellish-theme-darken-fg-face :background)))
    (t (:height 1.5)))
  "Face for the active window border."
  :group 'kwrooijen/modeline)

(defface kwrooijen/modeline-border-inactive
  `((t (:foreground ,(face-attribute 'embellish-theme-darken-fg-face :foreground)))
    (t (:background ,(face-attribute 'embellish-theme-darken-fg-face :background)))
    (t (:height 1.5)))
  "Face for the inactive window border."
  :group 'kwrooijen/modeline)

(defface kwrooijen/modeline-evil
  '((t (:height 1.0)))
  "Face for evil state indicator."
  :group 'kwrooijen/modeline)

(defface kwrooijen/modeline-winum
  '((t (:height 1.0)))
  "Face for winum number."
  :group 'kwrooijen/modeline)

(defface kwrooijen/modeline-buffer
  '((t (:height 1.0)))
  "Face for buffer/file name."
  :group 'kwrooijen/modeline)

(defface kwrooijen/modeline-scroll
  '((t (:height 1.0)))
  "Face for scroll percentage indicator."
  :group 'kwrooijen/modeline)

(defface kwrooijen/modeline-git-branch
  '((t (:height 1.0
        :inherit success)))
  "Face for Git branch."
  :group 'kwrooijen/modeline)

(defface kwrooijen/modeline-major-mode
  '((t (:height 1.0)))
  "Face for major mode text."
  :group 'kwrooijen/modeline)

;; Mode line face overrides handled by embellish-theme

(set-face-attribute 'kwrooijen/modeline-border nil :height 'unspecified :inherit 'default)
(set-face-attribute 'kwrooijen/modeline-border-inactive nil :height 1.5 :inherit 'embellish-theme-darken-fg-face)
#+END_SRC

** Active bar

#+BEGIN_SRC emacs-lisp
(defvar kwrooijen/modeline-raise 0.15)

(defun kwrooijen/modeline-r (s face)
  "Apply face and vertical raise to a modeline string."
  (propertize s 'face face 'display `(raise ,kwrooijen/modeline-raise)))

(defvar kwrooijen/modeline-active-border "▎")
(defvar kwrooijen/modeline-inactive-border "▎")
(defvar kwrooijen/modeline-selected-window nil)

(defun kwrooijen/modeline-win-focus-border (&optional force)
  "Show a border only when the window is active."
(set-face-attribute  'kwrooijen/modeline-border nil
        :foreground (face-attribute 'embellish-theme-foreground-fg-face :foreground)
        :background (face-attribute 'embellish-theme-darken-bg-face :background)
        :height 1.5)
(set-face-attribute  'kwrooijen/modeline-border-inactive nil
        :foreground (face-attribute 'embellish-theme-darken-fg-face :foreground)
        :background (face-attribute 'embellish-theme-darken-fg-face :background)
        :height 1.5)
  (if (or force (eq (selected-window) kwrooijen/modeline-selected-window))
      (propertize kwrooijen/modeline-active-border 'face 'kwrooijen/modeline-border)
    (propertize kwrooijen/modeline-inactive-border 'face 'kwrooijen/modeline-border-inactive)))

(defun kwrooijen/modeline--set-selected-window (&rest _)
  (unless (minibuffer-window-active-p (selected-window))
    (setq kwrooijen/modeline-selected-window (selected-window))))

(add-hook 'post-command-hook #'kwrooijen/modeline--set-selected-window)

(defun kwrooijen/modeline--force-update-visual (&rest _)
  "Force modeline update during evil visual state."
  (when (and (bound-and-true-p evil-local-mode)
             (eq evil-state 'visual))
    (force-mode-line-update)))

(add-hook 'post-command-hook #'kwrooijen/modeline--force-update-visual)
#+END_SRC

** Segments

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/modeline-evil-tag ()
  (when (bound-and-true-p evil-local-mode)
    (let* ((state evil-state)
           (tag
            (upcase
             (pcase state
               ('normal  " N ")
               ('insert  " I ")
               ('visual  " V ")
               ('replace " R ")
               (_ (substring (symbol-name state) 0 1)))))
           (face
            (pcase state
              ('normal  'success)
              ('visual  'region)
              ('insert  'error)
              ('replace 'warning)
              (_ 'kwrooijen/modeline-evil))))
      (kwrooijen/modeline-r tag face))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/modeline-winum ()
  (when (bound-and-true-p winum-mode)
    (let* ((num-str (format "%d " (or (winum-get-number) 1)))
           (face (if (eq (selected-window) kwrooijen/modeline-selected-window)
                     `(:inherit kwrooijen/modeline-winum :weight bold)
                   'kwrooijen/modeline-winum)))
      (kwrooijen/modeline-r num-str face))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/modeline-git-branch ()
  ""
  (when-let ((branch (and (fboundp 'magit-get-current-branch)
                          (magit-get-current-branch))))
    (kwrooijen/modeline-r
     (format "   %s" branch)
     'kwrooijen/modeline-git-branch)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/modeline-scroll ()
  (kwrooijen/modeline-r " %p%% " 'kwrooijen/modeline-scroll))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/modeline-line-col ()
  (if (and (bound-and-true-p evil-local-mode)
           (eq evil-state 'visual)
           (use-region-p))
      (let* ((beg (region-beginning))
             (end (region-end))
             (lines (count-lines beg end))
             (chars (abs (- end beg))))
        (kwrooijen/modeline-r (format " %d:%d" lines chars) 'kwrooijen/modeline-scroll))
    (kwrooijen/modeline-r " %l:%c" 'kwrooijen/modeline-scroll)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/modeline-buffer-name ()
  (let* ((dirty? (buffer-modified-p))
         (face   (if dirty?
                     `(:foreground ,(face-attribute 'embellish-theme-error-fg-face :foreground))
                   'kwrooijen/modeline-buffer)))
    (kwrooijen/modeline-r " %b" face)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/weekday-p (&optional time)
  "Return t if TIME (or now) is Monday through Friday."
  (let ((day-of-week (nth 6 (decode-time time))))
    (<= 1 day-of-week 5)))

(defun kwrooijen/clocked-today ()
  (let ((clocked-today (kwrooijen/org-clock-clocked-today)))
    (format "%d:%02d"
            (/ (floor clocked-today) 60)
            (% (floor clocked-today) 60))))

(defun kwrooijen/clocked-today-percentage ()
  (format "%d％"
          (round
           (* 100.0
              (/ (float (kwrooijen/org-clock-clocked-today))
                 480.0)))))


(defun kwrooijen/clocked-session ()
  (format "%d:%02d"
          (/ (org-clock-get-clocked-time) 60)
          (% (org-clock-get-clocked-time) 60)))

(defun kwrooijen/modeline-org-clock ()
  (when (kwrooijen/weekday-p)
    (let* ((clock-count (length org-clock-multi-clocks))
           (clocked-in-p (> clock-count 0))
           (face (if clocked-in-p 'embellish-theme-warning-fg-face 'embellish-theme-faded-fg-face)))
      (kwrooijen/modeline-r (format " [%d | %s | %s]" clock-count (kwrooijen/clocked-today) (kwrooijen/clocked-today-percentage)) face))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/modeline-mode ()
  (let* ((active? (eq (selected-window) kwrooijen/modeline-selected-window))
         (mode-face (if active?
                        `(:inherit kwrooijen/modeline-major-mode :weight bold)
                      'kwrooijen/modeline-major-mode)))
    (kwrooijen/modeline-r "  %m  " mode-face)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/modeline-zoom ()
  (let* ((zoom (/ (- (face-attribute 'default :height)
                     embellish-font-size) embellish-font-step))
         (affix (if (> zoom 0) "+" "-")))
    (unless (equal zoom 0)
      (kwrooijen/modeline-r (format " %s%s" zoom affix)
                            'embellish-theme-popout-fg-face))))
#+END_SRC


** Build modeline

Center spacing

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/modeline-center-space (right)
  (propertize
   " "
   'display
   `((space :align-to
            (- (+ right right-fringe right-margin)
               ,(string-width (format-mode-line right)))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defcustom kwrooijen/modeline-left
  (list
   '(:eval (kwrooijen/modeline-win-focus-border))
   '(:eval (kwrooijen/modeline-winum))
   '(:eval (kwrooijen/modeline-evil-tag))
   '(:eval (kwrooijen/modeline-buffer-name))
   '(:eval (kwrooijen/modeline-line-col))
   '(:eval (kwrooijen/modeline-scroll)))
  "Left side of the modeline."
  :type 'list
  :group 'kwrooijen/modeline)

(defcustom kwrooijen/modeline-right
  (list
   '(:eval (when (fboundp 'kwrooijen/modeline-agent-shell) (kwrooijen/modeline-agent-shell)))
   '(:eval (kwrooijen/modeline-org-clock))
   '(:eval (kwrooijen/modeline-zoom))
   '(:eval (kwrooijen/modeline-git-branch))
   '(:eval (kwrooijen/modeline-mode)))
  "Right side of the modeline."
  :type 'list
  :group 'kwrooijen/modeline)

(defun kwrooijen/mode-line ()
  (let* ((left  (delq nil kwrooijen/modeline-left))
         (right (delq nil kwrooijen/modeline-right)))
    (concat
     (format-mode-line left)
     (kwrooijen/modeline-center-space right)
     (format-mode-line right))))

(setq-default mode-line-format
              '((:eval (kwrooijen/mode-line))))

(when (buffer-live-p (get-buffer "*Messages*"))
  (with-current-buffer "*Messages*"
    (setq mode-line-format
          '((:eval (kwrooijen/mode-line))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; TODO implement project relative buffer name (with trimming)
(defun kwrooijen/buffer-path-from-project-root ()
  "Return path starting with the project root directory name.
If not a file buffer, return the buffer name."
  (interactive)
  (let* ((fname (buffer-file-name))
         (proj-root (when (fboundp 'kwrooijen/project-root)
                      (kwrooijen/project-root))))
    (cond
     ((and fname proj-root)
      (concat (file-name-nondirectory
               (directory-file-name proj-root))
              "/"
              (file-relative-name fname proj-root)))
     (fname (file-name-nondirectory fname))
     (t (buffer-name)))))
#+END_SRC

* Agent Shell
:PROPERTIES:
:PACKAGE:  agent-shell
:STRAIGHT: t
:END:

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(agent-shell-preferred-agent-config (agent-shell-anthropic-make-claude-code-config))
#+END_SRC

** General :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
 "l l" 'agent-shell
 "l m" 'agent-shell-set-session-model)
#+END_SRC


* Agent Review
:PROPERTIES:
:PACKAGE:  agent-review
:STRAIGHT: (agent-review :host github :repo "nineluj/agent-review")
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'agent-review-mode 'normal)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/agent-review ()
  "Run agent-review with Claude Code as the default agent."
  (interactive)
  (agent-review (agent-shell-anthropic-make-claude-code-config)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'agent-review
  (general-define-key
   :states '(normal)
   :keymaps 'agent-review-mode-map
   "m" #'agent-review-mark
   "u" #'agent-review-unmark
   "r" #'agent-review-refresh
   "M" #'agent-review-mark-all
   "U" #'agent-review-unmark-all
   "c" #'agent-review-copy-issues
   "E" #'agent-review-send-to-agent-shell)

  (evil-define-key 'normal agent-review-mode-map (kbd "<tab>") #'agent-review-jump-to-issue))
#+END_SRC

** General :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
 "l r" 'kwrooijen/agent-review)
#+END_SRC


* Agent Shell Manager
:PROPERTIES:
:PACKAGE:  agent-shell-manager
:STRAIGHT: (agent-shell-manager :host github :repo "jethrokuan/agent-shell-manager")
:END:

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(agent-shell-manager-side nil)
#+END_SRC

** Config :config:

#+BEGIN_SRC emacs-lisp
(push '("*Agent-Shell Buffers*" :height 6 :position bottom :stick t :dedicated t) popwin:special-display-config)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'agent-shell-manager-mode 'normal)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/agent-shell--active-project-dirs ()
  "Return list of project directories that have an active agent-shell."
  (let ((dirs nil))
    (dolist (buf (agent-shell-buffers))
      (when (buffer-live-p buf)
        (let ((name (buffer-name buf)))
          (when (string-match " Agent @ \\(.+\\)$" name)
            (push (file-truename (match-string 1 name)) dirs)))))
    dirs))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/agent-shell-start-in-project ()
  "Start agent-shell in a selected project and switch to it.
Projects that already have an active agent-shell are excluded from the list.
Uses Claude Code as the default agent."
  (interactive)
  (let* ((active-dirs (kwrooijen/agent-shell--active-project-dirs))
         (all-projects (project-known-project-roots))
         (available-projects
          (seq-filter (lambda (proj)
                        (not (member (file-truename proj) active-dirs)))
                      all-projects)))
    (if (null available-projects)
        (message "No projects available (all have active agent-shells)")
      (let* ((selected (completing-read "Start agent-shell in project: " available-projects nil t))
             (default-directory selected))
        (agent-shell-start :config (agent-shell-anthropic-make-claude-code-config))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/agent-shell--count-by-status ()
  "Return (:working N :total N :waiting N) plist of agent-shell buffers."
  (let ((working 0)
        (total 0)
        (waiting 0))
    (dolist (buf (agent-shell-buffers))
      (when (buffer-live-p buf)
        (let ((status (agent-shell-manager--get-status buf)))
          (unless (string= status "killed")
            (setq total (1+ total))
            (when (string= status "working")
              (setq working (1+ working)))
            (when (string= status "waiting")
              (setq waiting (1+ waiting)))))))
    (list :working working :total total :waiting waiting)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/modeline-agent-shell ()
  "Return modeline segment showing agent-shell status as [WORKING/TOTAL].
Prepends ! when any agent is waiting for permission."
  (when (fboundp 'agent-shell-buffers)
    (let* ((counts (kwrooijen/agent-shell--count-by-status))
           (working (plist-get counts :working))
           (total (plist-get counts :total))
           (waiting (plist-get counts :waiting)))
      (when (> total 0)
        (let* ((has-waiting (> waiting 0))
               (face (cond
                      (has-waiting 'embellish-theme-error-fg-face)
                      ((> working 0) 'embellish-theme-popout-fg-face)
                      (t 'embellish-theme-faded-fg-face)))
               (prefix (if has-waiting "!" "")))
          (kwrooijen/modeline-r (format " %s[%d/%d]" prefix working total) face))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/agent-shell-switch-agent ()
  "Switch to an agent-shell buffer using completing-read."
  (interactive)
  (let* ((buffers (seq-filter #'buffer-live-p (agent-shell-buffers)))
         (entries
          (mapcar (lambda (buf)
                    (let* ((name (buffer-name buf))
                           (status (agent-shell-manager--get-combined-status buf))
                           (dir (abbreviate-file-name
                                 (with-current-buffer buf default-directory))))
                      (list status dir name buf)))
                  buffers)))
    (if (null entries)
        (message "No agent-shell buffers")
      (let* ((max-status-width (apply #'max (mapcar (lambda (e) (string-width (nth 0 e))) entries)))
             (max-dir-width (apply #'max (mapcar (lambda (e) (length (nth 2 e))) entries)))
             (candidates
              (mapcar (lambda (entry)
                        (let* ((status (nth 0 entry))
                               (dir (nth 1 entry))
                               (name (nth 2 entry))
                               (buf (nth 3 entry))
                               (padded-status (string-pad status max-status-width))
                               (padded-name (string-pad name max-dir-width))
                               (label (concat padded-status
                                              "  "
                                              padded-name
                                              "  "
                                              (propertize dir 'face 'embellish-theme-faded-fg-face))))
                          (cons label buf)))
                      entries))
             (collection (lambda (str pred action)
                           (if (eq action 'metadata)
                               '(metadata (display-sort-function . identity)
                                          (cycle-sort-function . identity))
                             (complete-with-action action (mapcar #'car candidates) str pred))))
             (selected (completing-read "Switch to agent: " collection nil t))
             (buffer (cdr (assoc selected candidates))))
        (when buffer
          (pop-to-buffer buffer))))))
#+END_SRC

** General :general:

#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
 "l s" 'agent-shell-manager-toggle
 "l p" 'kwrooijen/agent-shell-start-in-project
 "l b" 'kwrooijen/agent-shell-switch-agent)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'agent-shell-manager
  (general-define-key
   :states '(normal)
   :keymaps 'agent-shell-manager-mode-map
   (kbd "RET") #'agent-shell-manager-goto
   "r" #'agent-shell-manager-refresh
   "l" #'agent-shell-manager-view-traffic
   "L" #'agent-shell-manager-toggle-logging
   "p" #'kwrooijen/agent-shell-start-in-project
   "C-c C-c" #'agent-shell-manager-interrupt)

  (evil-define-key 'normal agent-shell-manager-mode-map (kbd "<tab>") #'agent-shell-manager-goto))
#+END_SRC

* Request
:PROPERTIES:
:PACKAGE:  request
:STRAIGHT: t
:END:

* Org Asana
:PROPERTIES:
:PACKAGE:  org-asana
:END:

** General :general:

#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
 "as" '(org-asana-pull :which-key "Asana Pull")
 "aS" '(org-asana-redownload :which-key "Asana Redownload"))
#+END_SRC

* Elfeed
:PROPERTIES:
:PACKAGE:  elfeed
:STRAIGHT: t
:END:
** Custom :custom:
Max body width (using shr renderer)

#+BEGIN_SRC emacs-lisp
(shr-width 80)
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
;; Elfeed face overrides handled by embellish-theme
#+END_SRC

#+BEGIN_SRC emacs-lisp
(kwrooijen/find-and-load-file "~/.dotfiles/elfeed-feeds.el")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defvar kwrooijen/elfeed-default-tags '("saved"))

(defun kwrooijen/elfeed-search-tag-all (tag)
  "Apply TAG to all selected entries."
  (interactive
   (list
    (intern
     (completing-read
      "Tag: "
      kwrooijen/elfeed-default-tags
      nil          ; predicate
      nil))))      ; require-match → allow new tags
(elfeed-search-tag-all tag))

(defun kwrooijen/elfeed-entry-tags-at-point ()
  "Return a list of tag names (strings) for the entry at point."
  (when-let ((entry (elfeed-search-selected :single)))
    (mapcar #'symbol-name (elfeed-entry-tags entry))))


(defun kwrooijen/elfeed-search-untag-all (tag)
  "Remove TAG from all selected Elfeed entries."
  (interactive
   (let ((tags (kwrooijen/elfeed-entry-tags-at-point)))
     (unless tags
       (user-error "No tags on entry"))
     (list
      (intern
       (completing-read
        "Remove tag: "
        tags
        nil
        t)))))
(elfeed-search-untag-all tag)
  )

#+END_SRC


#+BEGIN_SRC emacs-lisp

#+END_SRC

** General :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "ay" '(elfeed :which-key "Elfeed"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(general-define-key
 :states '(normal)
 :keymaps 'elfeed-search-mode-map
 "r" #'elfeed-search-untag-all-unread
 "R" #'elfeed-search-tag-all-unread
 "t" #'kwrooijen/elfeed-search-tag-all
 "T" #'kwrooijen/elfeed-search-untag-all
 "u" #'elfeed-update
 "/" #'elfeed-search-live-filter
 "?" #'elfeed-search-set-filter)
#+END_SRC




* Message
:PROPERTIES:
:PACKAGE:  message
:END:
** Config :config:
#+BEGIN_SRC emacs-lisp
;; Message face overrides handled by embellish-theme
#+END_SRC



* Olivetti
:PROPERTIES:
:PACKAGE:  olivetti
:STRAIGHT: t
:END:

** Hook :hook:
#+BEGIN_SRC emacs-lisp
(elfeed-show-mode . olivetti-mode)
#+END_SRC

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(olivetti-minimum-body-width 90)
#+END_SRC


* Eww
:PROPERTIES:
:PACKAGE:  eww
:STRAIGHT: t
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(advice-add 'eww-readable :after
            (lambda (&rest _)
              (when (plist-get eww-data :readable)
                (olivetti-mode 1))))
#+END_SRC

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(browse-url-browser-function 'eww-browse-url)
#+END_SRC

** Hook :hook:
#+BEGIN_SRC emacs-lisp
(eww-mode . pixel-scroll-precision-mode)
#+END_SRC

* Spray
:PROPERTIES:
:PACKAGE:  spray
:STRAIGHT: t
:END:

A speed reading mode for Emacs

** Config :config:
#+BEGIN_SRC emacs-lisp
(defun kwrooijen/spray ()
  "Copy current buffer into a new buffer and start spray-mode."
  (interactive)
  (let* ((source (current-buffer))
         (text (with-current-buffer source
                 (buffer-string)))
         (buf (generate-new-buffer
               (format "*spray: %s*" (buffer-name source)))))
    (switch-to-buffer buf)
    (insert text)
    (goto-char (point-min))
    (spray-mode 1)
    (use-local-map (copy-keymap spray-mode-map))
    (local-set-key (kbd "q") #'kill-current-buffer)
    (local-set-key (kbd "SPC") #'spray-start/stop)))
#+END_SRC

* Dired
:PROPERTIES:
:PACKAGE: dired
:END:

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(dired-listing-switches "-laoh")
#+END_SRC

** Hook :hook:
#+BEGIN_SRC emacs-lisp
((dired-mode . hl-line-mode))
#+END_SRC

** General :general:
#+BEGIN_SRC emacs-lisp
(general-define-key
 :states 'normal
 :keymaps 'dired-mode-map
 ";" #'find-file)
#+END_SRC

* Diredfl
:PROPERTIES:
:PACKAGE: diredfl
:STRAIGHT: t
:DEFER: t
:END:

** Init :init:

Enable diredfl mode globally
#+BEGIN_SRC emacs-lisp
(diredfl-global-mode 1)

#+END_SRC

#+BEGIN_SRC emacs-lisp
(defface kwrooijen/diredfl-owner
  '((((background dark)) (:inherit embellish-theme-subtle-fg-face))
    (t                   (:inherit embellish-theme-subtle-fg-face)))
  "Face for the file owner field in Dired."
  :group 'diredfl)

(defvar kwrooijen/diredfl-owner 'kwrooijen/diredfl-owner)

#+END_SRC

#+BEGIN_SRC emacs-lisp
(defface kwrooijen/diredfl-size
  '((((background dark)) (:inherit embellish-theme-popout-fg-face))
    (t                   (:inherit embellish-theme-popout-fg-face)))
  "Face for the file group field in Dired."
  :group 'diredfl)

(defvar kwrooijen/diredfl-size 'kwrooijen/diredfl-size)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defface kwrooijen/diredfl-acl-flag
  '((((background dark)) (:inherit embellish-theme-subtle-fg-face))
    (t                   (:inherit embellish-theme-subtle-fg-face)))
  "Face for the ACL '+' flag in Dired permission strings."
  :group 'diredfl)

(defvar kwrooijen/diredfl-acl-flag 'kwrooijen/diredfl-acl-flag)
#+END_SRC

Add custom faces to diredfl-font-lock-keywords-1

#+BEGIN_SRC emacs-lisp
(add-to-list
 'diredfl-font-lock-keywords-1
 '("^..\\([-bcdlps]\\([r-][w-][x-]\\)\\{3\\}\\)\\([+@]\\)"
   (3 kwrooijen/diredfl-acl-flag)))

(add-to-list
 'diredfl-font-lock-keywords-1
 '("^..\\S-+ +[0-9]+ +\\([^ ]+\\) +\\([^ ]+\\) +"
   (1 kwrooijen/diredfl-owner)
   (2 kwrooijen/diredfl-size)))
#+END_SRC

Remove diredfl-match-ignored-extensions
#+BEGIN_SRC emacs-lisp
(setq diredfl-font-lock-keywords-1
        (cl-remove-if
         (lambda (entry)
           (and (listp entry)
                (eq (car entry) 'diredfl-match-ignored-extensions)))
         diredfl-font-lock-keywords-1))
#+END_SRC

* Dired Preview
:PROPERTIES:
:PACKAGE:  dired-preview
:STRAIGHT: t
:END:

** General :general:
#+BEGIN_SRC emacs-lisp
(:keymaps 'dired-mode-map
 :states 'normal
"p" 'dired-preview-mode)
#+END_SRC

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(dired-preview-delay 0)
#+END_SRC

* Casual
:PROPERTIES:
:PACKAGE:  casual
:STRAIGHT: t
:END:

** General :general:
#+BEGIN_SRC emacs-lisp
(general-define-key
  :states 'normal
  :keymaps 'dired-mode-map
  "'" #'casual-dired-tmenu)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(general-define-key
  :states 'normal
  :keymaps 'csv-mode-map
  "'" #'casual-csv-tmenu)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(general-define-key
  :states 'normal
  :keymaps 'org-agenda-mode-map
  "'" #'casual-agenda-tmenu)
#+END_SRC

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(setq casual-dired-listing-switches '("--group-directories-first" "-laoh"))
#+END_SRC

* Magit
:PROPERTIES:
:PACKAGE:  magit
:STRAIGHT: t
:DEMAND: t
:END:

** Options

#+BEGIN_SRC emacs-lisp
(defcustom kwrooijen/git-magit-use-winum t
  "Use winum to select Magit windows.
This will bind the following keys:
M-1: winum-select-window-1
M-2: winum-select-window-2
M-3: winum-select-window-3
M-4: winum-select-window-4
"
  :type 'boolean
  :group 'kwrooijen/git))
#+END_SRC

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(magit-diff-refine-hunk 'all)
#+END_SRC


** Config :config:

HACK: Override the magit-section-show-level-*-all functions to use
winum. For some reason I can't override the keybindings using General.

#+BEGIN_SRC emacs-lisp
(when kwrooijen/git-magit-use-winum
  (defun magit-section-show-level-1-all () (interactive) (winum-select-window-1))
  (defun magit-section-show-level-2-all () (interactive) (winum-select-window-2))
  (defun magit-section-show-level-3-all () (interactive) (winum-select-window-3))
  (defun magit-section-show-level-4-all () (interactive) (winum-select-window-4)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key magit-status-mode-map (kbd "M-RET") 'magit-diff-visit-file-other-window)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Diff face overrides handled by embellish-theme
#+END_SRC

** Hook :hook:

Enter Evil Insert Mode automatically when starting a Git commit.

#+BEGIN_SRC emacs-lisp
(git-commit-mode . evil-insert-state)
#+END_SRC

** Bindings :general:

#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
"g g" '(magit-status :which-key "Git status"))
#+END_SRC




* Smerge
:PROPERTIES:
:PACKAGE: smerge
:END:

** Bindings :general:

#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
"gu" '(smerge-keep-upper :which-key "Merge keep upper")
"gl" '(smerge-keep-lower :which-key "Merge keep lower")
"ga" '(smerge-keep-all :which-key "Merge keep all"))
#+END_SRC

* Magit Todos
:PROPERTIES:
:PACKAGE:  magit-todos
:STRAIGHT: t
:AFTER: magit
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(magit-todos-mode 1)
#+END_SRC

# TODO Magit delta sometimes breaks, so we should have an easy way to toggle it.
# * Magit Delta
# :PROPERTIES:
# :PACKAGE:  magit-delta
# :STRAIGHT: t
# :END:

# ** Hook :hook:
# #+BEGIN_SRC emacs-lisp
# (magit-mode . magit-delta-mode)
# #+END_SRC

# ** Custom :custom:
# #+BEGIN_SRC emacs-lisp
# (magit-delta-delta-args '("--max-line-distance" "0.6" "--true-color" "always" "--color-only" "--syntax-theme" "Nord" ))
# #+END_SRC

* Anzu
:PROPERTIES:
:PACKAGE: anzu
:STRAIGHT: t
:END:
** Custom :custom:

Disable Anzu by default
#+BEGIN_SRC emacs-lisp
(anzu-mode-line-update-function (lambda(&rest _)))
(anzu-mode-lighter "")
#+END_SRC

** config :config:
#+BEGIN_SRC emacs-lisp
(global-anzu-mode +1)
#+END_SRC

** Binding :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
"s r" 'anzu-query-replace
"s R" 'anzu-query-replace-regexp)

("M-%" 'anzu-query-replace)
("C-M-%" 'anzu-query-replace-regexp)
#+END_SRC


* Evil Anzu
:PROPERTIES:
:PACKAGE: evil-anzu
:STRAIGHT: t
:END:

* Anzu Overlay
:PROPERTIES:
:PACKAGE: anzu-overlay
:STRAIGHT: (anzu-overlay :type git :host github :repo "kwrooijen/anzu-overlay")
:END:

** Init :init:
#+BEGIN_SRC emacs-lisp
(require 'anzu)
(require 'evil)
(require 'iedit)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(anzu-overlay-mode 1)
#+END_SRC

* Helpful
:PROPERTIES:
:PACKAGE: helpful
:STRAIGHT: t
:END:

** General :general:

#+BEGIN_SRC emacs-lisp
("C-h f" #'helpful-callable)
("C-h v" #'helpful-variable)
("C-h k" #'helpful-key)
("C-h x" #'helpful-command)
#+END_SRC

* Eshell
:PROPERTIES:
:PACKAGE: eshell
:END:

** Config :config:

Use dired colors

#+BEGIN_SRC emacs-lisp
(require 'em-ls)
(require 'em-prompt)
;; Eshell face overrides handled by embellish-theme
#+END_SRC

*** Functions

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/eshell-toggle ()
  "Toggles between eshell and the previous buffer."
  (interactive)
  (if (string= (buffer-name) "*eshell*")
      (bury-buffer "*eshell*")
    (progn (eshell)
           (evil-insert-state))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/project-eshell-toggle ()
  "Opens an eshell buffer in the root of the current project."
  (interactive)
  (if (string= (buffer-name) "*eshell*")
      (bury-buffer "*eshell*")
    (progn (project-eshell)
           (evil-insert-state))))
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "e e" 'kwrooijen/eshell-toggle
  "e p" 'kwrooijen/project-eshell-toggle)
#+END_SRC

* Vterm
:PROPERTIES:
:PACKAGE: vterm
:STRAIGHT: t
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(define-key vterm-mode-map (kbd "M-1") 'winum-select-window-1)
(define-key vterm-mode-map (kbd "M-2") 'winum-select-window-2)
(define-key vterm-mode-map (kbd "M-3") 'winum-select-window-3)
(define-key vterm-mode-map (kbd "M-4") 'winum-select-window-4)
(define-key vterm-mode-map (kbd "M-5") 'winum-select-window-5)
(define-key vterm-mode-map (kbd "M-6") 'winum-select-window-6)
(define-key vterm-mode-map (kbd "M-7") 'winum-select-window-7)
(define-key vterm-mode-map (kbd "M-8") 'winum-select-window-8)
(define-key vterm-mode-map (kbd "M-<backspace>")
            (lambda()
              (interactive)
              (let ((p (point))
                    (_ (evil-backward-word-begin))
                    (e (point)))
                (evil-collection-vterm-delete p e))))

(defun kwrooijen/toggle-vterm ()
  (interactive)
  (if (eq major-mode 'vterm-mode)
      (delete-window)
    (vterm)))

(defun kwrooijen/project-vterm ()
  (interactive)
  (let ((default-directory (kwrooijen/project-root))
        (vterm-buffer-name (concat "*vterm " (kwrooijen/project-name) "*")))
    (if (eq major-mode 'vterm-mode)
        (delete-window)
      (if (get-buffer vterm-buffer-name)
          (popwin:special-display-popup-window vterm-buffer-name)
        (vterm vterm-buffer-name)))))
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "e E" 'kwrooijen/toggle-vterm
  "e P" 'kwrooijen/project-vterm)
#+END_SRC

* Restclient
:PROPERTIES:
:PACKAGE: restclient
:STRAIGHT: t
:END:

* Ellama
:PROPERTIES:
:PACKAGE: ellama
:STRAIGHT: t
:END:

** Init :init:
#+BEGIN_SRC emacs-lisp
(require 'llm-ollama)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setopt ellama-provider
        (make-llm-ollama
         :chat-model "mistral:7b-instruct-v0.2-q6_K"
         :embedding-model "mistral:7b-instruct-v0.2-q6_K"))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(setopt ellama-providers
        '(("zephyr" . (make-llm-ollama
                       :chat-model "zephyr:7b-beta-q6_K"
                       :embedding-model "zephyr:7b-beta-q6_K"))
          ("mistral" . (make-llm-ollama
                        :chat-model "mistral:7b-instruct-v0.2-q6_K"
                        :embedding-model "mistral:7b-instruct-v0.2-q6_K"))))
#+END_SRC

*** Ellama chatbox

Some functions to interact with the ellama chatbox.

The chatbox is a special buffer that is used to send text to the
ellama chatbot. This is more user friendly than using the minibuffer.

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/ellama-send-buffer ()
  "Send the buffer to the ellama chatbox"
  (interactive)
  (when (equal (buffer-name) "*ellama-chatbox*")
    (let ((text (buffer-substring-no-properties (point-min) (point-max))))
      (erase-buffer)
      (ellama-chat text))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/ellama-toggle-chatbox ()
  "Toggle the ellama chatbox"
  (interactive)
  (if (equal (current-buffer) (get-buffer "*ellama-chatbox*"))
      (popwin:close-popup-window)
    (progn
      (popwin:special-display-popup-window "*ellama-chatbox*" :height 0.2 :position 'bottom)
      (with-current-buffer "*ellama-chatbox*"
        (prog-mode)
        (local-set-key (kbd "M-RET") 'kwrooijen/ellama-send-buffer)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/ellama-send-buffer-context ()
  (interactive)
  (let ((buffer-string (buffer-substring-no-properties (point-min) (point-max))))
    (ellama-chat (format "=== CONTEXT START === %s === CONTEXT END ===" buffer-string))))
#+END_SRC

** Keybindings :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
"e l" 'kwrooijen/ellama-toggle-chatbox
"e b" 'kwrooijen/ellama-send-buffer-context)
#+END_SRC


* Dictionary
:PROPERTIES:
:PACKAGE: dictionary
:END:

** Binding :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "sd" 'dictionary-search)
#+END_SRC


* GPTel
:PROPERTIES:
:PACKAGE: gptel
:STRAIGHT: t
:END:

gptel is a simple Large Language Model chat client for Emacs, with
support for multiple models and backends. It works in the spirit of
Emacs, available at any time and uniformly in any buffer.

** Init :init:
#+BEGIN_SRC emacs-lisp
(require 'gptel)
;; -*- lexical-binding: t -*-

(defun kwrooijen/gptel-apply-changes ()
  "Apply changes to the current buffer. Simply replace current buffer with *gptel-temp* buffer."
  (interactive)
  (let* ((temp-buffer (get-buffer "*gptel-temp*"))
         (current-buffer (current-buffer)))
    (if temp-buffer
        (progn
          (replace-buffer-contents temp-buffer)
          (save-buffer)
          (kill-buffer temp-buffer))
      (message "No temp buffer found"))))

(defun kwrooijen/gptel-send-buffer-with ()
  "Send the current buffer with `gptel-request' as well as user input."
  (interactive)
  ;; TODO Keep a log of diffs for context
  (let* ((temp-buffer (get-buffer "*gptel-temp*"))
         (current-buffer (current-buffer))
         (string "")
         (string (concat string "=== ORIGINAL CODE START ===\n"))
         (string (concat string (buffer-string)))
         (string (concat string "=== ORIGINAL CODE END ===\n"))
         (string (concat string "=== CODE START ===\n"))
         (string (concat string (if temp-buffer
                                    (with-current-buffer temp-buffer
                                      (buffer-string))
                                  (buffer-string))))
         (string (concat string "=== CODE STOP ===\n"))
         (string (concat string "=== CONTEXT START ===\n"))
         (string (concat string "ONLY RESPONSE WITH THE MODIFIED VERSION IF THE CONTENTS OF `CODE`\n"))
         (string (concat string "DO NOT REMOVE ANY CODE THAT WASN'T ASKED TO BE REMOVED\n"))
         (string (concat string "DO NOT REMOVE ANY COMMENTS\n"))
         (string (concat string "DO NOT REMOVE ANY # COMMENTS\n"))
         (string (concat string "DO NOT INCLUDE THE `CODE` SECTION\n"))
         (string (concat string "DO NOT INCLUDE THE `CONTEXT` SECTION\n"))
         (string (concat string "DO NOT INCLUDE YOUR OWN COMMENTS\n"))
         (string (concat string "DO NOT WRAP THE CODE IN BACKTICKS"))
         (string (concat string "=== CONTEXT STOP ===\n"))
         (string (concat string
                         (read-string "Prompt: " nil nil nil nil))))
    (gptel-request string :callback (lambda (response something)
                                      (let ((temp-buffer (get-buffer-create "*gptel-temp*")))
                                        (with-current-buffer temp-buffer
                                          (erase-buffer)
                                          (insert response "\n")
                                          (diff-buffers current-buffer temp-buffer)))))))


(defun kwrooijen/gptel-copy-write-paragraph ()
  "Send the current buffer with `gptel-request' as well as user input."
  (interactive)
  (setq lexical-binding t)
  (let* ((temp-buffer (get-buffer "*gptel-temp*"))
         (current-buffer (current-buffer))
         (paragraph
          (progn
            (backward-paragraph)
            (forward-char 1)
            (set-mark (point))
            (forward-paragraph)
            (forward-char -2)
            (buffer-substring-no-properties (region-beginning) (region-end))))
         (string "")
         (string (concat string "=== PARAGRAPH START ===\n"))
         (string (concat string paragraph))
         (string (concat string "=== PARAGRAPH STOP ===\n"))
         (string (concat string "=== CONTEXT START ===\n"))
         (string (concat string "YOU ARE A COPY WRITER\n"))
         (string (concat string "YOU WRITE CLEAR AND DIRECT CONTENT. NOT SUGARCOATED\n"))
         (string (concat string "YOU WRITE HELPFUL, CORRECT, AND POLITE CONTENT\n"))
         (string (concat string "MAKE A SUGGESTION FOR THE FOLLOWING PARAGRAPH\n"))
         (string (concat string "YOU ONLY RESPOND WITH THE MODIFIED VERSION OF THE `PARAGRAPH`\n"))
         (string (concat string "INCLUDE ALL FORMATTING SUCH AS NEWLINES\n"))
         (string (concat string "DO NOT START YOUR RESPONSE WITH THINGS LIKE: 'Here is a suggested rephrasing:'\n"))
         (string (concat string "DO NOT END YOUR RESPONSE WITH THINGS LIKE: 'Let me know if you'd like me to suggest any further changes!'"))
         (string (concat string "DO NOT START OR END YOUR RESPONSE WITH BACKTICKS\n"))
         (string (concat string "DO NOT START OR END YOUR RESPONSE WITH === PARAGRAPH START / END === \n"))
         (string (concat string "=== CONTEXT STOP ===\n")))
    (gptel-request string :callback (lambda (response something)
                                      (let ((temp-buffer (get-buffer-create "*gptel-temp*")))
                                        (with-current-buffer temp-buffer
                                          (erase-buffer)
                                          (kill-new response)
                                          (insert response "\n")
                                          (display-buffer temp-buffer t)))))))


(defun kwrooijen/gptel-cancel ()
  "Cancel the current operation."
  (interactive)
  (let* ((temp-buffer (get-buffer "*gptel-temp*"))
         (diff-buffer (get-buffer "*Diff*")))
    (when temp-buffer (kill-buffer temp-buffer))
    (when diff-buffer (kill-buffer diff-buffer))
    (message "Operation cancelled")))
#+END_SRC

#+RESULTS:
: kwrooijen/gptel-cancel

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(gptel-model "llama3-70b-8192")
(gptel-backend (gptel-make-openai
                "Groq"
                :host "api.groq.com"
                :endpoint "/openai/v1/chat/completions"
                :stream t
                :key #'read-groq-key
                :models '("llama3-70b-8192")))
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(defvar gptel--known-backends '())

(defvar read-groq-key-cache nil)

(defun read-groq-key ()
  "Read $HOME .gptel.api.gpg file and return string."
  (if read-groq-key-cache
      read-groq-key-cache
    (setq read-groq-key-cache
          (with-temp-buffer
            (insert-file-contents (expand-file-name "~/.gptel.api.gpg"))
            (buffer-string)))))
#+END_SRC

** Binding :general:
#+BEGIN_SRC emacs-lisp
(:keymaps 'gptel-mode-map
"M-RET" 'gptel-send)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
 "ja" 'kwrooijen/gptel-apply-changes
 "ji" 'kwrooijen/gptel-send-buffer-with
 "jp" 'kwrooijen/gptel-copy-write-paragraph
 "jc" 'kwrooijen/gptel-cancel)
#+END_SRC


* GLSL
:PROPERTIES:
:PACKAGE: glsl-mode
:STRAIGHT: (:host github :repo "jimhourihan/glsl-mode" :files ("dist" "*.el"))
:END:

This is a major mode for Emacs providing editing conveniences for the
OpenGL Shading Language (GLSL). It currently handles GLSL version 4.6,
including many recent Vulkan extensions.

* Denote
:PROPERTIES:
:PACKAGE:  denote
:STRAIGHT: t
:END:
** Hook :hook:
#+BEGIN_SRC emacs-lisp
(dired-mode . denote-dired-mode)
#+END_SRC

** General :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
 "d n" 'denote
 "d r" 'denote-rename-file
 "d l" 'denote-link
 "d b" 'denote-backlinks
 "d d" 'denote-dired
 "d g" 'denote-grep)
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(setq denote-directory (expand-file-name "~/Documents/notes/"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(denote-rename-buffer-mode 1)
#+END_SRC

* Org Agenda
:PROPERTIES:
:PACKAGE:  org-agenda
:END:

** Config :config:

Automatically save any org buffers when making changes in org agenda.

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/agenda-org-save-all-org-buffers ()
  (when (equal major-mode 'org-agenda-mode)
    ;; TODO Inhibit messages
    (org-save-all-org-buffers))
  (when (equal major-mode 'org-mode)
    ;; TODO Inhibit messages
    (save-buffer)))

(add-hook 'org-after-todo-state-change-hook #'kwrooijen/agenda-org-save-all-org-buffers)
(add-hook 'org-clock-in-hook                #'kwrooijen/agenda-org-save-all-org-buffers)
(add-hook 'org-clock-out-hook               #'kwrooijen/agenda-org-save-all-org-buffers)

;; Set TODO state to IN PROGRESS when clocking in
(defun kwrooijen/org-clock-multi-set-in-progress ()
  "Set the heading at point to IN PROGRESS."
  (save-excursion
    (org-back-to-heading t)
    (unless (string= (org-get-todo-state) "IN PROGRESS")
      (org-todo "IN PROGRESS"))))

(advice-add 'org-clock-multi-clock-in :after #'kwrooijen/org-clock-multi-set-in-progress)

;; Save org buffers after org-clock-multi operations
(advice-add 'org-clock-multi-clock-in      :after #'org-save-all-org-buffers)
(advice-add 'org-clock-multi-clock-out     :after #'org-save-all-org-buffers)
(advice-add 'org-clock-multi-clock-out-all :after #'org-save-all-org-buffers)
(advice-add 'org-clock-multi-clock-cancel  :after #'org-save-all-org-buffers)
#+END_SRC




#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-clock-multi-skip-unless-clocked-or-paused ()
  "Skip function for agenda: skip unless heading is clocked or paused."
  (let ((dominated t))
    (let ((id (org-entry-get nil "CLOCK_MULTI_ID")))
      (when id
        (when (or (org-clock-multi--find-clock-by-key id)
                  (member id org-clock-multi-paused))
          (setq dominated nil))))
    (when dominated
      (org-end-of-subtree t))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("D" "Done tasks"
         todo "DONE")
        ("k" "Currently clocked"
         ((alltodo "" ((org-agenda-skip-function
                        #'kwrooijen/org-clock-multi-skip-unless-clocked-or-paused)))))))

(org-todo-dashboard-install)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-agenda-done ()
  (interactive)
  (org-agenda nil "D"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(cl-defun kwrooijen/org-todo-select-and-change (&key from to tag)
  "Select a task in state FROM and change it to state TO.
When TAG is non-nil, only show tasks that have that tag."
  (let (entries max-tag-width max-closed-width)
    (dolist (file (org-agenda-files))
      (with-current-buffer (find-file-noselect file)
        (org-with-wide-buffer
         (goto-char (point-min))
         (while (re-search-forward org-heading-regexp nil t)
           (when (and (equal (org-get-todo-state) from)
                      (or (null tag)
                          (member tag (org-get-tags))))
             (let* ((heading (org-get-heading t t t t))
                    (tags (org-get-tags))
                    (tag-str (if tags (string-join tags ":") ""))
                    (closed (or (org-entry-get nil "CLOSED") ""))
                    (marker (point-marker)))
               (push (list tag-str closed heading marker) entries)))))))
    (if (null entries)
        (message "No %s tasks found" from)
      (setq entries (sort entries (lambda (a b)
                                    (string> (nth 1 a) (nth 1 b)))))
      (setq max-tag-width (apply #'max (mapcar (lambda (e) (length (nth 0 e))) entries)))
      (setq max-closed-width (apply #'max (mapcar (lambda (e) (length (nth 1 e))) entries)))
      (let* ((candidates
              (mapcar
               (lambda (entry)
                 (let* ((tag-str (nth 0 entry))
                        (closed (nth 1 entry))
                        (heading (nth 2 entry))
                        (marker (nth 3 entry))
                        (padded-tag (string-pad tag-str max-tag-width))
                        (padded-closed (string-pad closed max-closed-width))
                        (label (concat (propertize padded-tag 'face 'embellish-theme-faded-fg-face)
                                       "  "
                                       (propertize padded-closed 'face 'embellish-theme-faded-fg-face)
                                       "  " heading)))
                   (cons label marker)))
               entries))
             (collection (lambda (str pred action)
                          (if (eq action 'metadata)
                              '(metadata (display-sort-function . identity)
                                         (cycle-sort-function . identity))
                            (complete-with-action action (mapcar #'car candidates) str pred))))
             (selection (completing-read (format "%s -> %s: " from to) collection nil t))
             (marker (cdr (assoc selection candidates))))
        (when marker
          (with-current-buffer (marker-buffer marker)
            (goto-char marker)
            (org-todo to)
            (save-buffer)
            (kwrooijen/org-edit-subtree)))))))

(defvar kwrooijen/org-todo-find--candidates nil
  "Current candidates for `kwrooijen/org-todo-find-and-edit'.")

(defun kwrooijen/org-todo-find--kill-edit-indirect (marker)
  "Kill any edit-indirect buffer covering MARKER's position.
Signals an error if the edit-indirect buffer has unsaved changes."
  (with-current-buffer (marker-buffer marker)
    (when-let* ((ov (edit-indirect--search-for-edit-indirect
                     (marker-position marker) (1+ (marker-position marker))))
                (buf (overlay-get ov 'edit-indirect-buffer)))
      (when (buffer-live-p buf)
        (when (buffer-modified-p buf)
          (user-error "Edit-indirect buffer has unsaved changes — save or abort it first"))
        (with-current-buffer buf
          (edit-indirect-abort))))))

(defun kwrooijen/org-todo-find--throw-action (action)
  "Throw ACTION for the currently selected candidate."
  (when-let* ((cand (nth vertico--index vertico--candidates))
              (marker (cdr (assoc cand kwrooijen/org-todo-find--candidates))))
    (throw 'kwrooijen/org-todo-find--action (cons action marker))))

(defun kwrooijen/org-todo-find--change-state ()
  "Change the TODO state of the currently selected candidate."
  (interactive)
  (kwrooijen/org-todo-find--throw-action 'change-state))

(defun kwrooijen/org-todo-find--clock-in ()
  "Clock in the currently selected candidate."
  (interactive)
  (kwrooijen/org-todo-find--throw-action 'clock-in))

(defun kwrooijen/org-todo-find--clock-out ()
  "Clock out the currently selected candidate."
  (interactive)
  (kwrooijen/org-todo-find--throw-action 'clock-out))

(defun kwrooijen/org-todo-find--clock-pause ()
  "Pause the clock for the currently selected candidate."
  (interactive)
  (kwrooijen/org-todo-find--throw-action 'clock-pause))

(defun kwrooijen/org-todo-find--open-shell ()
  "Open the agent-shell for the currently selected candidate."
  (interactive)
  (kwrooijen/org-todo-find--throw-action 'open-shell))

(defun kwrooijen/org-todo-find--preview ()
  "Preview the currently selected candidate without closing the minibuffer."
  (interactive)
  (when-let* ((cand (nth vertico--index vertico--candidates))
              (marker (cdr (assoc cand kwrooijen/org-todo-find--candidates))))
    (let* ((buf (save-window-excursion
                  (with-current-buffer (marker-buffer marker)
                    (goto-char marker)
                    (kwrooijen/org-edit-subtree)
                    (goto-char (point-min))
                    (current-buffer))))
           (win (get-buffer-window buf)))
      (if (and win (window-live-p win))
          ;; Already visible — do nothing
          nil
        ;; Close existing popwin popup, then display the new buffer
        (popwin:close-popup-window)
        (popwin:display-buffer buf)))
    (select-window (active-minibuffer-window))))

(defvar kwrooijen/org-todo-find-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-t") #'kwrooijen/org-todo-find--change-state)
    (define-key map (kbd "C-i") #'kwrooijen/org-todo-find--clock-in)
    (define-key map (kbd "C-o") #'kwrooijen/org-todo-find--clock-out)
    (define-key map (kbd "C-p") #'kwrooijen/org-todo-find--clock-pause)
    (define-key map (kbd "C-s") #'kwrooijen/org-todo-find--open-shell)
    (define-key map (kbd "<tab>") #'kwrooijen/org-todo-find--preview)
    map)
  "Keymap active during `kwrooijen/org-todo-find-and-edit'.")

(cl-defun kwrooijen/org-todo-find-and-edit (&key states tag)
  "Select a task in one of STATES and open it with edit-subtree.
STATES is a list of todo state strings.
When TAG is non-nil, only show tasks that have that tag.
Press C-t to change the TODO state of the selected entry."
  (let ((keep-going t))
    (while keep-going
      (setq keep-going nil)
      (let (entries max-tag-width max-closed-width)
        (dolist (file (org-agenda-files))
          (with-current-buffer (find-file-noselect file)
            (org-with-wide-buffer
             (goto-char (point-min))
             (while (re-search-forward org-heading-regexp nil t)
               (when (and (member (org-get-todo-state) states)
                          (or (null tag)
                              (member tag (org-get-tags))))
                 (let* ((heading (org-get-heading t t t t))
                        (tags (org-get-tags))
                        (tag-str (if tags (string-join tags ":") ""))
                        (state (or (org-get-todo-state) ""))
                        (closed (or (org-entry-get nil "CLOSED") ""))
                        (id (org-entry-get nil "CLOCK_MULTI_ID"))
                        (clocked (and id (org-clock-multi--find-clock-by-key id) t))
                        (paused (and id (not clocked) (member id org-clock-multi-paused) t))
                        (marker (point-marker))
                        (project (org-entry-get nil "PROJECT" t))
                        (worktree (org-entry-get nil "WORKTREE"))
                        (agent-status
                         (if (and project worktree)
                             (let* ((wt-path (expand-file-name
                                              worktree
                                              (file-name-concat (expand-file-name project)
                                                                agent-shell-worktree--subdirectory)))
                                    (shell-buf (org-agent-shell--find-shell-buffer wt-path)))
                               (if shell-buf
                                   (agent-shell-manager--get-combined-status shell-buf)
                                 (propertize "No Shell" 'face 'font-lock-comment-face)))
                           "")))
                   (push (list tag-str state closed heading marker clocked paused agent-status) entries)))))))
        (if (null entries)
            (message "No %s tasks found" (string-join states "/"))
          (setq entries (sort entries (lambda (a b)
                                        (let ((ca (nth 5 a)) (cb (nth 5 b))
                                              (pa (nth 6 a)) (pb (nth 6 b)))
                                          (cond
                                           ((and ca (not cb)) t)
                                           ((and (not ca) cb) nil)
                                           ((and pa (not pb)) t)
                                           ((and (not pa) pb) nil)
                                           (t (string> (nth 2 a) (nth 2 b))))))))
          (setq max-tag-width (apply #'max (mapcar (lambda (e) (length (nth 0 e))) entries)))
          (let ((max-state-width (apply #'max (mapcar (lambda (e) (length (nth 1 e))) entries)))
                (max-agent-width (apply #'max (mapcar (lambda (e) (string-width (nth 7 e))) entries))))
            (setq max-closed-width (apply #'max (mapcar (lambda (e) (length (nth 2 e))) entries)))
            (let* ((candidates
                    (mapcar
                     (lambda (entry)
                       (let* ((tag-str (nth 0 entry))
                              (state (nth 1 entry))
                              (closed (nth 2 entry))
                              (heading (nth 3 entry))
                              (marker (nth 4 entry))
                              (clocked (nth 5 entry))
                              (paused (nth 6 entry))
                              (agent-status (nth 7 entry))
                              (padded-tag (string-pad tag-str max-tag-width))
                              (padded-agent (string-pad agent-status max-agent-width))
                              (padded-state (propertize (string-pad state max-state-width)
                                                        'face (org-get-todo-face state)))
                              (padded-closed (string-pad closed max-closed-width))
                              (label (concat (propertize padded-tag 'face 'embellish-theme-faded-fg-face)
                                             "  "
                                             padded-agent
                                             "  "
                                             padded-state
                                             "  "
                                             (propertize padded-closed 'face 'embellish-theme-faded-fg-face)
                                             "  " heading)))
                         (when clocked
                           (put-text-property 0 1 'kwrooijen/clocked t label))
                         (when paused
                           (put-text-property 0 1 'kwrooijen/paused t label))
                         (cons label marker)))
                     entries))
                   (kwrooijen/org-todo-find--candidates candidates)
                   (group-fn (lambda (cand transform)
                               (if transform cand
                                 (cond
                                  ((get-text-property 0 'kwrooijen/clocked cand) "Clocked In")
                                  ((get-text-property 0 'kwrooijen/paused cand) "Paused")
                                  (t "Tasks")))))
                   (collection (lambda (str pred action)
                                 (if (eq action 'metadata)
                                     `(metadata (display-sort-function . identity)
                                                (cycle-sort-function . identity)
                                                (group-function . ,group-fn))
                                   (complete-with-action action (mapcar #'car candidates) str pred))))
                   (result (catch 'kwrooijen/org-todo-find--action
                             (minibuffer-with-setup-hook
                                 (lambda () (use-local-map (make-composed-keymap
                                                            kwrooijen/org-todo-find-map
                                                            (current-local-map))))
                               (cons 'select (completing-read "Select: " collection nil t))))))
              (pcase (car result)
                ('select
                 (when-let* ((marker (cdr (assoc (cdr result) candidates))))
                   (with-current-buffer (marker-buffer marker)
                     (goto-char marker)
                     (kwrooijen/org-edit-subtree)
                     (goto-char (point-min)))))
                ('change-state
                 (let ((marker (cdr result))
                       (edit-indirect--inhibit-read-only t))
                   (kwrooijen/org-todo-find--kill-edit-indirect marker)
                   (with-current-buffer (marker-buffer marker)
                     (save-excursion
                       (goto-char marker)
                       (org-todo))))
                 (setq keep-going t))
                ('clock-in
                 (let ((marker (cdr result))
                       (edit-indirect--inhibit-read-only t))
                   (kwrooijen/org-todo-find--kill-edit-indirect marker)
                   (with-current-buffer (marker-buffer marker)
                     (save-excursion
                       (goto-char marker)
                       (org-clock-multi-clock-in))))
                 (setq keep-going t))
                ('clock-out
                 (let ((marker (cdr result))
                       (edit-indirect--inhibit-read-only t))
                   (kwrooijen/org-todo-find--kill-edit-indirect marker)
                   (with-current-buffer (marker-buffer marker)
                     (save-excursion
                       (goto-char marker)
                       (org-clock-multi-clock-out))))
                 (setq keep-going t))
                ('clock-pause
                 (let ((marker (cdr result))
                       (edit-indirect--inhibit-read-only t))
                   (kwrooijen/org-todo-find--kill-edit-indirect marker)
                   (with-current-buffer (marker-buffer marker)
                     (save-excursion
                       (goto-char marker)
                       (org-clock-multi-clock-pause))))
                 (setq keep-going t))
                ('open-shell
                 (let ((marker (cdr result)))
                   (with-current-buffer (marker-buffer marker)
                     (save-excursion
                       (goto-char marker)
                       (org-agent-shell-open-shell)))))))))))))

(defun kwrooijen/org-todo-find-done-work ()
  "Select a DONE or CANCELLED :work: task and edit it."
  (interactive)
  (kwrooijen/org-todo-find-and-edit :states '("DONE" "CANCELLED") :tag "work"))

(defun kwrooijen/org-todo-find-waiting-work ()
  "Select a WAITING :work: task and edit it."
  (interactive)
  (kwrooijen/org-todo-find-and-edit :states '("WAITING") :tag "work"))

(defun kwrooijen/org-todo-find-active-work ()
  "Select a TODO or IN PROGRESS :work: task and edit it."
  (interactive)
  (kwrooijen/org-todo-find-and-edit :states '("TODO" "IN PROGRESS" "WAITING") :tag "work"))

(defun kwrooijen/org-todo-find-all ()
  "Select a TODO or IN PROGRESS :work: task and edit it."
  (interactive)
  (kwrooijen/org-todo-find-and-edit :states '("TODO" "IN PROGRESS" "WAITING")))

(defun kwrooijen/org-todo-unarchive ()
  "Select a DONE task and change it back to TODO."
  (interactive)
  (kwrooijen/org-todo-select-and-change :from "DONE" :to "TODO"))

(defun kwrooijen/org-todo-unarchive-work ()
  "Select a DONE :work: task and change it back to TODO."
  (interactive)
  (kwrooijen/org-todo-select-and-change :from "DONE" :to "TODO" :tag "work"))

(defun kwrooijen/org-todo-unwait ()
  "Select a WAITING task and change it back to TODO."
  (interactive)
  (kwrooijen/org-todo-select-and-change :from "WAITING" :to "TODO"))

(defun kwrooijen/org-todo-unwait-work ()
  "Select a WAITING :work: task and change it back to TODO."
  (interactive)
  (kwrooijen/org-todo-select-and-change :from "WAITING" :to "TODO" :tag "work"))
#+END_SRC



Custom loading bar for work.
#+BEGIN_SRC emacs-lisp


(defun kwrooijen/org-agenda-loading-bar ()
  "Return a textual loading bar based on today's clocked minutes."
  (let* ((max 480.0)
         (current (float (kwrooijen/org-clock-clocked-today)))
         (ratio (min 1.0 (/ current max)))
         (width 30)
         (filled (round (* width ratio)))
         (empty (- width filled))
         (percent (round (* 100 ratio))))
    (format
     "%s\n\nWork Progress: [%s%s] %d%% (%d / 480 min)\n\n%s\n\n"
     (make-string (- (window-width) 1) ?─)
     (make-string filled ?█)
     (make-string empty ?░)
     percent
     (round current)
     (make-string (- (window-width) 1) ?─))))

(defun kwrooijen/org-agenda-insert-loading-bar ()
  "Insert loading bar at the top of the agenda buffer."
  ;; TODO only when current day is mon - fri
  ;; (when (derived-mode-p 'org-agenda-mode)
  ;;   (let ((inhibit-read-only t))
  ;;     (goto-char (point-min))
  ;;     (insert (kwrooijen/org-agenda-loading-bar))))
)

(add-hook 'org-agenda-finalize-hook
          #'kwrooijen/org-agenda-insert-loading-bar)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-client-names ()
  "Return a list of client names derived from org files."
  (let ((dir (expand-file-name "~/Documents/org/todos/client/")))
    (mapcar #'file-name-base
            (directory-files dir nil "\\.org$"))))

(defun kwrooijen/org-set-clockreport-match (client)
  "Update only :match in `org-agenda-clockreport-parameter-plist`."
  (interactive
   (list (completing-read "Clockreport match: " (append (kwrooijen/org-client-names) '("work")) nil nil)))
  (setq org-agenda-clockreport-parameter-plist
        (plist-put org-agenda-clockreport-parameter-plist
                   :match
                   client))
  (org-agenda-redo))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'org-agenda-mode 'normal)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-agenda-edit-subtree ()
  "Edit the subtree at point in an indirect buffer.
Use C-c C-c to commit changes, C-c C-k to abort."
  (interactive)
  (let* ((marker (or (org-get-at-bol 'org-marker)
                     (org-agenda-error)))
         (buffer (marker-buffer marker))
         (pos (marker-position marker)))
    (with-current-buffer buffer
      (goto-char pos)
      (kwrooijen/org-edit-subtree))))

(evil-define-key 'normal org-agenda-mode-map (kbd "<tab>") #'kwrooijen/org-agenda-edit-subtree)
#+END_SRC

Add functionality to toggle habits in agenda.

#+BEGIN_SRC emacs-lisp
(defvar kwrooijen/org-habit-shown-p t)

(defun kwrooijen/org-habit-toggle ()
  (interactive)
  (setq kwrooijen/org-habit-shown-p (not kwrooijen/org-habit-shown-p))
  (org-agenda-redo))

(require 'org-habit)
#+END_SRC

** Custom :custom:

Adjsut the org agenda format. We add `EFFORT` (`[%e]`) to the `agenda`
view. (NOTE: Removed `%e` for now, to see how we can organize it nicely

#+BEGIN_SRC emacs-lisp
(setq org-agenda-prefix-format
 '((agenda . "[%-5e] %-12:c%?-12t% s")
   (todo . " %i %-12:c")
   (tags . " %i %-12:c")
   (search . " %i %-12:c")))
#+END_SRC

Don't show scheduled TODOs if they have been done today

#+BEGIN_SRC emacs-lisp
(org-agenda-todo-ignore-scheduled 'future)
#+END_SRC

Org agenda table, include ASANA in header for ticket ids

#+BEGIN_SRC emacs-lisp
(org-agenda-clockreport-parameter-plist
 (list :maxlevel 2
       :narrow nil
       :properties '("ASANA")
       :match "+work"
       :indent nil
       :tcolumns 1))
#+END_SRC

List of keywords which a TODO heading can have.

#+BEGIN_SRC emacs-lisp
(org-todo-keywords '((sequence
                      "TODO(t)"
                      "IN PROGRESS(p)"
                      "WAITING(w)"
                      "|"
                      "CANCELLED(c!)"
                      "DONE(d!)")))
#+END_SRC

Set the faces for specific org keywords

#+BEGIN_SRC emacs-lisp
(org-todo-keyword-faces
      '(("TODO"        . (:inherit embellish-theme-salient-fg-face))
        ("IN PROGRESS" . (:inherit embellish-theme-popout-fg-face))
        ("WAITING"     . (:inherit embellish-theme-faded-fg-face))
        ("DONE"        . (:inherit org-done))
        ("CANCELLED"   . (:inherit org-done))))
#+END_SRC


Customize agenda renderer to optionally filter out habits.

#+BEGIN_SRC emacs-lisp
(org-agenda-skip-function-global
 (lambda ()
   (when (and (org-is-habit-p) (not kwrooijen/org-habit-shown-p))
     (org-agenda-skip-entry-if 'todo 'any))))
#+END_SRC



** General :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "aa" '(org-agenda-list :which-key "Org Agenda")
  "ao" '(org-agenda :which-key "Org Commands")
  "at" '(org-todo-list :which-key "Org Todos")
  "ad" '(kwrooijen/org-agenda-done :which-key "Org Done")
  "ac" '(org-capture :which-key "Org Capture")
  "aD" '(org-todo-dashboard-open :which-key "Dashboard")
  "af" '(kwrooijen/org-todo-find-active-work :which-key "Find Active")
  "aF" '(kwrooijen/org-todo-find-all :which-key "Find all")
  "au" '(kwrooijen/org-todo-find-done-work :which-key "Find Done")
  "aw" '(kwrooijen/org-todo-find-waiting-work :which-key "Find Waiting"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(general-define-key
:states '(normal)
:keymaps 'org-agenda-mode-map
  (kbd "TAB") #'kwrooijen/org-agenda-edit-subtree
  (kbd "RET") #'org-agenda-switch-to
  (kbd "SPC") #'org-agenda-show-and-scroll-up

  (kbd "C-k") #'org-agenda-kill
  (kbd "C-n") #'org-agenda-next-line
  (kbd "C-p") #'org-agenda-previous-line
  ;; "C-_" #'org-agenda-undo
  "!" #'org-agenda-toggle-deadlines
  "#" #'org-agenda-dim-blocked-tasks
  "$" #'org-agenda-archive
  "%" #'org-agenda-bulk-mark-regexp
  "+" #'org-agenda-priority-up
  "," #'org-agenda-priority
  "-" #'org-agenda-priority-down
  "." #'org-agenda-goto-today
  "/" #'org-agenda-filter
  ":" #'org-agenda-set-tags
  ";" #'kwrooijen/org-set-clockreport-match
  "<" #'org-agenda-filter-by-category
  "=" #'org-agenda-filter-by-regexp
   ">" #'org-agenda-date-prompt
  "?" #'org-agenda-show-the-flagging-note
  "A" #'org-agenda-append-agenda
  "B" #'org-agenda-bulk-action
  "C" #'org-agenda-convert-date
  "D" #'org-agenda-toggle-diary
  "E" #'org-agenda-entry-text-mode
  "F" #'org-agenda-follow-mode
  "G" #'org-agenda-toggle-time-grid
  "H" #'org-agenda-holidays
  "I" #'org-clock-multi-agenda-clock-in
  "K" #'org-habit-toggle-display-in-agenda
  "L" #'org-agenda-recenter
  "N" #'org-agenda-next-item
  "O" #'org-clock-multi-agenda-clock-out
  "P" #'org-clock-multi-agenda-clock-pause
  "Q" #'org-agenda-Quit
  "R" #'org-agenda-clockreport-mode
  "V" #'org-clock-data-agenda-chart-mode
  "S" #'org-agenda-sunrise-sunset
  "T" #'org-agenda-show-tags
  (kbd "M-m") #'org-agenda-bulk-unmark
  (kbd "M-M") #'org-agenda-bulk-unmark-all
  (kbd "C-o") #'org-clock-multi-agenda-clock-out-all
  "m" #'org-agenda-bulk-mark
  "M" #'org-agenda-bulk-mark-all
  "X" #'org-clock-multi-agenda-clock-cancel
  "[" #'org-agenda-manipulate-query-add
  "\\" #'org-agenda-filter-by-tag
  "]" #'org-agenda-manipulate-query-subtract
  "^" #'org-agenda-filter-by-top-headline
  "_" #'org-agenda-filter-by-effort
  "a" #'org-agenda-archive-default-with-confirmation
  "b" #'org-agenda-earlier
  "c" #'org-agenda-goto-calendar
  "d" #'org-agenda-day-view
  "e" #'org-agenda-set-effort
  "f" #'org-agenda-later
  "g" #'org-agenda-redo-all
  "H" #'org-agenda-holidays
  "i" #'org-agenda-diary-entry
  "n" #'org-agenda-goto-date
  "p" #'org-agenda-capture
  "L" #'org-agenda-log-mode
  "o" #'org-agenda-month-view

  "k" #'org-agenda-previous-line
  "j" #'org-agenda-next-line
  "l" #'evil-forward-char
  "h" #'evil-backward-char

  "q" #'org-agenda-quit
  "r" #'org-agenda-redo
  "s" #'org-save-all-org-buffers
  "t" #'org-agenda-todo
  "u" #'org-agenda-undo
  "U" #'org-agenda-redo
  "v" #'org-agenda-view-mode-dispatch
  "w" #'org-agenda-week-view
  "x" #'org-agenda-exit
  "y" #'org-agenda-year-view
  "z" #'org-agenda-add-note
  "{" #'org-agenda-manipulate-query-add-re
  "|" #'org-agenda-filter-remove-all
  "}" #'org-agenda-manipulate-query-subtract-re
  "~" #'org-agenda-limit-interactively
  (kbd "DEL") #'org-agenda-show-scroll-down)
#+END_SRC


* Org Capture
:PROPERTIES:
:PACKAGE:  org-capture
:END:

** Init :init:

Read org capture templates from other file.

#+BEGIN_SRC emacs-lisp
(kwrooijen/find-and-load-file "~/.dotfiles/org-capture-templates.el")
#+END_SRC


* Calendar
:PROPERTIES:
:PACKAGE:  calendar
:END:

** Config :config:

#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'calendar-mode 'normal)
#+END_SRC

** General :general:
#+BEGIN_SRC emacs-lisp
(general-define-key
 :states '(normal)
 :keymaps 'calendar-mode-map
 (kbd "RET") #'org-calendar-select
 "C-@" #'calendar-set-mark
 "C-a" #'calendar-beginning-of-week
 "h" #'calendar-backward-day
 "l" #'calendar-forward-day
 "j" #'calendar-forward-week
 "k" #'calendar-backward-week
 "C-e" #'calendar-end-of-week
 "C-l" #'calendar-recenter
 "C-v" #'calendar-scroll-left-three-months
 (kbd "SPC") #'scroll-other-window
 "-" #'negative-argument
 "." #'calendar-goto-today
 "<" #'calendar-scroll-right
 ">" #'calendar-scroll-left
 "?" #'calendar-goto-info-node
 "D" #'diary-view-other-diary-entries
 "M" #'calendar-lunar-phases
 "S" #'calendar-sunrise-sunset
 "[" #'calendar-backward-year
 "]" #'calendar-forward-year
 "a" #'calendar-list-holidays
 "c" #'org-calendar-goto-agenda
 "d" #'diary-view-entries
 ;; "h" #'calendar-cursor-holidays
 "m" #'diary-mark-entries
 "o" #'calendar-other-month
 "q" #'calendar-exit
 "s" #'diary-show-all-entries
 "u" #'calendar-unmark
 "x" #'calendar-mark-holidays
 "{" #'calendar-backward-month
 "}" #'calendar-forward-month
 ;; "DEL" #'scroll-other-window-down
 ;; "S-SPC" #'scroll-other-window-down
 ;; "C-SPC" #'calendar-set-mark

 (kbd "C-c C-l") #'calendar-redraw

 (kbd "C-x C-x") #'calendar-exchange-point-and-mark
 (kbd "C-x <") #'calendar-scroll-right
 (kbd "C-x >") #'calendar-scroll-left
 (kbd "C-x [") #'calendar-backward-year
 (kbd "C-x ]") #'calendar-forward-year

 (kbd "M-<") #'calendar-beginning-of-year
 (kbd "M-=") #'calendar-count-days-region
 (kbd "M->") #'calendar-end-of-year
 (kbd "M-a") #'calendar-beginning-of-month
 (kbd "M-e") #'calendar-end-of-month
 (kbd "M-v") #'calendar-scroll-right-three-months
 (kbd "M-{") #'calendar-backward-month
 (kbd "M-}") #'calendar-forward-month

 "A a" #'appt-add
 "A d" #'appt-delete

 "H m" #'cal-html-cursor-month
 "H y" #'cal-html-cursor-year

 "g C" #'calendar-chinese-goto-date
 "g D" #'calendar-goto-day-of-year
 "g a" #'calendar-astro-goto-day-number
 "g b" #'calendar-bahai-goto-date
 "g c" #'calendar-iso-goto-date
 "g d" #'calendar-goto-date
 "g e" #'calendar-ethiopic-goto-date
 "g f" #'calendar-french-goto-date
 "g h" #'calendar-hebrew-goto-date
 "g i" #'calendar-islamic-goto-date
 "g j" #'calendar-julian-goto-date
 "g k" #'calendar-coptic-goto-date
 "g p" #'calendar-persian-goto-date
 "g w" #'calendar-iso-goto-week

 "i a" #'diary-insert-anniversary-entry
 "i b" #'diary-insert-block-entry
 "i c" #'diary-insert-cyclic-entry
 "i d" #'diary-insert-entry
 "i m" #'diary-insert-monthly-entry
 "i w" #'diary-insert-weekly-entry
 "i y" #'diary-insert-yearly-entry

 "p C" #'calendar-chinese-print-date
 "p a" #'calendar-astro-print-day-number
 "p b" #'calendar-bahai-print-date
 "p c" #'calendar-iso-print-date
 "p d" #'calendar-print-day-of-year
 "p e" #'calendar-ethiopic-print-date
 "p f" #'calendar-french-print-date
 "p h" #'calendar-hebrew-print-date
 "p i" #'calendar-islamic-print-date
 "p j" #'calendar-julian-print-date
 "p k" #'calendar-coptic-print-date
 "p m" #'calendar-mayan-print-date
 "p o" #'calendar-print-other-dates
 "p p" #'calendar-persian-print-date

 "t M" #'cal-tex-cursor-month-landscape
 "t Y" #'cal-tex-cursor-year-landscape
 "t d" #'cal-tex-cursor-day
 "t m" #'cal-tex-cursor-month
 "t y" #'cal-tex-cursor-year

 "t f W" #'cal-tex-cursor-filofax-week
 "t f d" #'cal-tex-cursor-filofax-daily
 "t f w" #'cal-tex-cursor-filofax-2week
 "t f y" #'cal-tex-cursor-filofax-year

 "t w 1" #'cal-tex-cursor-week
 "t w 2" #'cal-tex-cursor-week2
 "t w 3" #'cal-tex-cursor-week-iso
 "t w 4" #'cal-tex-cursor-week-monday
 "t w W" #'cal-tex-cursor-week2-summary)
#+END_SRC


* Org Clock
:PROPERTIES:
:PACKAGE:  org-clock
:END:
** Config :config:
#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-clock--today-range ()
  "Return (START . END) of today in Unix seconds."
  (let* ((now (decode-time (current-time)))
         (start (float-time
                 (encode-time 0 0 0
                              (nth 3 now)
                              (nth 4 now)
                              (nth 5 now)))))
    (cons start (+ start 86400))))


(defun kwrooijen/org-clock--today-start ()
  "Return Unix time (seconds) for start of today."
  (let* ((now (decode-time (current-time))))
    (encode-time 0 0 0
                 (nth 3 now)   ; day
                 (nth 4 now)   ; month
                 (nth 5 now)))) ; year

(defun kwrooijen/org-clock--open-clocked-today ()
  "Return minutes from currently running clocks that fall within today.
Uses org-clock-multi-clocks for multiple simultaneous clocks.
Note: Clock start times are stored in minutes since epoch."
  (let ((total 0))
    ;; Convert day boundaries to minutes for consistent comparison
    (pcase-let* ((`(,day-start-sec . ,day-end-sec) (kwrooijen/org-clock--today-range))
                 (day-start (floor (/ day-start-sec 60)))
                 (day-end (floor (/ day-end-sec 60)))
                 (now (floor (/ (float-time (current-time)) 60))))
      (dolist (clock org-clock-multi-clocks)
        (let ((clock-start (cdr clock)))  ; already in minutes
          (when (< clock-start day-end)
            (setq total (+ total
                           (max 0 (- (min now day-end)
                                     (max clock-start day-start)))))))))
    (when (> total 0) total)))

(defun kwrooijen/org-clock-clocked-today (&optional as-duration)
  "Return total time clocked today across `org-agenda-files`.
If AS-DURATION is non-nil, return an Org duration string."
  (let* ((start (float-time (kwrooijen/org-clock--today-start)))
         (end   (+ start 86400))
         (minutes (or (kwrooijen/org-clock--open-clocked-today) 0)))
    (dolist (file (org-agenda-files))
      (with-current-buffer (find-file-noselect file)
        (setq minutes
              (+ minutes (org-clock-sum start end)))))
    (if as-duration
        (org-duration-from-minutes minutes)
      minutes)))
#+END_SRC

* Org Clock Data
:PROPERTIES:
:PACKAGE:  org-clock-data
:END:

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(org-clock-data-bar-value 'earnings)
#+END_SRC

* Functions

Org heading search

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-search-heading ()
  "Jump to an Org heading using full outline paths."
  (interactive)
  (let (candidates)
    (org-map-entries
     (lambda ()
       (let* ((pos (point))
              (path (org-get-outline-path t t))
              (display (string-join path " > ")))
         (push (cons display pos) candidates)))
     nil 'file)
    (let* ((choice
            (completing-read
             "Heading: "
             (mapcar #'car candidates)
             nil t))
           (pos (cdr (assoc choice candidates))))
      (goto-char pos)
      (org-show-context)
      (org-show-entry)
      (org-narrow-to-subtree))))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-table-current-line-columns ()
  "Return the columns of the current line in an Org table as a list of plain strings."
  (when (org-at-table-p)
    (mapcar (lambda (s) (substring-no-properties (string-trim s)))
            (org-split-string (buffer-substring-no-properties
                               (line-beginning-position)
                               (line-end-position))
                              "|"))))

(defun orgtbl-to-semicol (table params)
  "Convert the `orgtbl-mode' TABLE to TAB separated material."
  (orgtbl-to-generic table (org-combine-plists '(:sep ";") params)))

(defun kwrooijen/org-table-export ()
  (interactive)
  (let* ((export-file (kwrooijen/org-table-get-export-file)))
    (org-table-export (when export-file (expand-file-name export-file)) "orgtbl-to-semicol")))

(defun kwrooijen/org-table-get-export-file ()
  "Return the value of the #+EXPORT: keyword associated with the current table."
  (interactive)
  (unless (org-at-table-p) (user-error "Not in a table"))
  (save-excursion
    (let (export-file)
      ;; Move to the line before the table
      (goto-char (org-table-begin))
      (forward-line -1)
      (end-of-line)
      ;; Search backward for #+EXPORT: within a reasonable range
      (when (re-search-backward "^#\\+EXPORT:[ \t]*\\(.*\\)$" nil t)
        (setq export-file (match-string 1)))
      (if export-file
          (string-trim export-file)  ; Remove leading/trailing whitespace
        (user-error "No #+EXPORT: keyword found above the table")))))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-mode-setup ()
    (interactive)
    (setq-local evil-auto-indent nil)
    (auto-fill-mode 0)
    (electric-indent-mode -1))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-toggle-inline-image-at-point ()
  (org-toggle-inline-images
   nil
   (org-element-begin (org-element-context))
   (org-element-end (org-element-context))))

(defun kwrooijen/file-path-from-URI (file-string)
  (when (and file-string (string-match "file:\\(?://\\)?\\(.*\\)" file-string))
    (string-trim (match-string 1 file-string))))

(defun kwrooijen/org-code-open-link-file ()
  (let ((link (org-element-context))
        (value (plist-get (plist-get (org-element-context) 'fixed-width) :value)))
    (when-let (file (kwrooijen/file-path-from-URI value))
      (when (file-exists-p file)
        (next-line)
        (beginning-of-line)
        (newline)
        (previous-line)
        (insert (format "[[%s]]" file))
        (kwrooijen/org-toggle-inline-image-at-point)
        (beginning-of-line)))))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun +org--toggle-inline-images-in-subtree (&optional beg end refresh)
  "Refresh inline image previews in the current heading/tree."
  (let* ((beg (or beg
                  (if (org-before-first-heading-p)
                      (save-excursion (point-min))
                    (save-excursion (org-back-to-heading) (point)))))
         (end (or end
                  (if (org-before-first-heading-p)
                      (save-excursion (org-next-visible-heading 1) (point))
                    (save-excursion (org-end-of-subtree) (point)))))
         (overlays (cl-remove-if-not (lambda (ov) (overlay-get ov 'org-image-overlay))
                                     (ignore-errors (overlays-in beg end)))))
    (dolist (ov overlays nil)
      (delete-overlay ov)
      (setq org-inline-image-overlays (delete ov org-inline-image-overlays)))
    (when (or refresh (not overlays))
      (org-display-inline-images t t beg end)
      t)))

(defun +org-get-todo-keywords-for (&optional keyword)
  "Returns the list of todo keywords that KEYWORD belongs to."
  (when keyword
    (cl-loop for (type . keyword-spec)
             in (cl-remove-if-not #'listp org-todo-keywords)
             for keywords =
             (mapcar (lambda (x) (if (string-match "^\\([^(]+\\)(" x)
                                     (match-string 1 x)
                                   x))
                     keyword-spec)
             if (eq type 'sequence)
             if (member keyword keywords)
             return keywords)))

(defun +org/dwim-at-point (&optional arg)
  "Do-what-I-mean at point.

If on a:
- checkbox list item or todo heading: toggle it.
- citation: follow it
- headline: cycle ARCHIVE subtrees, toggle latex fragments and inline images in
  subtree; update statistics cookies/checkboxes and ToCs.
- clock: update its time.
- footnote reference: jump to the footnote's definition
- footnote definition: jump to the first reference of this footnote
- timestamp: open an agenda view for the time-stamp date/range at point.
- table-row or a TBLFM: recalculate the table's formulas
- table-cell: clear it and go into insert mode. If this is a formula cell,
  recaluclate it instead.
- babel-call: execute the source block
- statistics-cookie: update it.
- src block: execute it
- latex fragment: toggle it.
- link: follow it
- otherwise, refresh all inline images in current tree."
  (interactive "P")
  (if (button-at (point))
      (call-interactively #'push-button)
    (let* ((context (org-element-context))
           (type (org-element-type context)))
      ;; skip over unimportant contexts
      (while (and context (memq type '(verbatim code bold italic underline strike-through subscript superscript)))
        (setq context (org-element-property :parent context)
              type (org-element-type context)))
      (pcase type
        ((or `citation `citation-reference)
         (org-cite-follow context arg))
        (`fixed-width (kwrooijen/org-code-open-link-file))

        (`headline
         (cond ((memq (bound-and-true-p org-goto-map)
                      (current-active-maps))
                (org-goto-ret))
               ((and (fboundp 'toc-org-insert-toc)
                     (member "TOC" (org-get-tags)))
                (toc-org-insert-toc)
                (message "Updating table of contents"))
               ((string= "ARCHIVE" (car-safe (org-get-tags)))
                (org-force-cycle-archived))
               ((or (org-element-property :todo-type context)
                    (org-element-property :scheduled context))
                (org-todo)))
         ;; Update any metadata or inline previews in this subtree
         (org-update-checkbox-count)
         (org-update-parent-todo-statistics)
         (when (and (fboundp 'toc-org-insert-toc)
                    (member "TOC" (org-get-tags)))
           (toc-org-insert-toc)
           (message "Updating table of contents"))
         (let* ((beg (if (org-before-first-heading-p)
                         (line-beginning-position)
                       (save-excursion (org-back-to-heading) (point))))
                (end (if (org-before-first-heading-p)
                         (line-end-position)
                       (save-excursion (org-end-of-subtree) (point))))
                (overlays (ignore-errors (overlays-in beg end)))
                (latex-overlays
                 (cl-find-if (lambda (o) (eq (overlay-get o 'org-overlay-type) 'org-latex-overlay))
                             overlays))
                (image-overlays
                 (cl-find-if (lambda (o) (overlay-get o 'org-image-overlay))
                             overlays)))
           (+org--toggle-inline-images-in-subtree beg end)
           (if (or image-overlays latex-overlays)
               (org-clear-latex-preview beg end)
             (org--latex-preview-region beg end))))

        (`clock (org-clock-update-time-maybe))

        (`footnote-reference
         (org-footnote-goto-definition (org-element-property :label context)))

        (`footnote-definition
         (org-footnote-goto-previous-reference (org-element-property :label context)))

        ((or `planning `timestamp)
         (org-follow-timestamp-link))

        ((or `table `table-row)
         (if (org-at-TBLFM-p)
             (org-table-calc-current-TBLFM)
           (ignore-errors
             (save-excursion
               (goto-char (org-element-property :contents-begin context))
               (org-call-with-arg 'org-table-recalculate (or arg t))))))

        (`table-cell
         ;; (org-table-blank-field)
         (org-table-recalculate arg)
         ;; (when (and (string-empty-p (string-trim (org-table-get-field)))
         ;;            (bound-and-true-p evil-local-mode))
         ;;   (evil-change-state 'insert))
)

        (`babel-call
         (org-babel-lob-execute-maybe))

        (`statistics-cookie
         (save-excursion (org-update-statistics-cookies arg)))

        ((or `src-block `inline-src-block)
         (org-babel-execute-src-block arg))

        ((or `latex-fragment `latex-environment)
         (org-latex-preview arg))

        (`link
         (let* ((lineage (org-element-lineage context '(link) t))
                (path (org-element-property :path lineage)))
           (if (or (equal (org-element-property :type lineage) "img")
                   (and path (image-type-from-file-name path)))
               (+org--toggle-inline-images-in-subtree
                (org-element-property :begin lineage)
                (org-element-property :end lineage))
             (org-open-at-point arg))))

        (`paragraph
         (+org--toggle-inline-images-in-subtree))

        ((guard (org-element-property :checkbox (org-element-lineage context '(item) t)))
         (let ((match (and (org-at-item-checkbox-p) (match-string 1))))
           (org-toggle-checkbox (if (equal match "[ ]") '(16)))))

        (_
         (if (or (org-in-regexp org-ts-regexp-both nil t)
                 (org-in-regexp org-tsr-regexp-both nil  t)
                 (org-in-regexp org-link-any-re nil t))
             (call-interactively #'org-open-at-point)
           (+org--toggle-inline-images-in-subtree
            (org-element-property :begin context)
            (org-element-property :end context))))))))
#+END_SRC

* Org Ox gfm
:PROPERTIES:
:PACKAGE: ox-gfm
:STRAIGHT: t
:END:

** Init :init:

Override org-gfm-inner-template so that it doesn't generate a ToC.

#+BEGIN_SRC emacs-lisp
(defun org-gfm-inner-template (contents info)
  "Return body of document after converting it to Markdown syntax.
CONTENTS is the transcoded contents string.  INFO is a plist
holding export options."
    (org-trim (concat contents "\n" (org-gfm-footnote-section info))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-confirm-elisp-link-function nil)
#+END_SRC

* Wisdom
:PROPERTIES:
:PACKAGE: wisdom
:END:

** General :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/local-leader
   :keymaps 'org-mode-map
   "c p" 'wisdom-preview
   "c P" 'wisdom-preview-mode
   "c c" 'wisdom-reload-current-buffer
   "c a" 'wisdom-reload)
#+END_SRC

* Org
:PROPERTIES:
:PACKAGE: org
:STRAIGHT: t
:AFTER: evil
:END:

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(org-confirm-babel-evaluate nil)

(org-pretty-entities nil)

  ;; Don't add space between heading and tags
(org-tags-column 0)

  ;; Fold (hide) blocks on startup
(org-startup-folded t)
(org-image-actual-width nil)
(org-src-fontify-natively t)
(org-edit-src-persistent-message nil)
(org-fontify-quote-and-verse-blocks nil)
(org-src-tab-acts-natively t)
(org-src-preserve-indentation t)
(org-edit-src-content-indentation 2)
(org-hide-block-startup nil)
(org-cycle-separator-lines 2)
(org-log-into-drawer t)
(org-duration-format (quote h:mm))
#+END_SRC

Improve M-RET on a heading line.
Don't split the heading line, don't split the content in a heading line.

#+BEGIN_SRC emacs-lisp
(org-M-RET-may-split-line '((default . nil)))
(org-insert-heading-respect-content t)
#+END_SRC

Improve Org TODO logging, place them in properties.

#+BEGIN_SRC emacs-lisp
(org-log-done t)
(org-log-into-drawer t)
#+END_SRC

Org agenda files. All TODOs go in here.

#+BEGIN_SRC emacs-lisp
(org-agenda-files '("~/Documents/org/todos" "~/Documents/org/todos/client"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(org-directory "~/Documents/org/notes/")
#+END_SRC



** Config :config:

#+BEGIN_SRC emacs-lisp
(require 'org-clock)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/org-heading-1-next ()
  (interactive)
    (org-next-visible-heading 1)
    (recenter-top-bottom 2))

(defun kwrooijen/org-heading-1-prev ()
  (interactive)
    (org-next-visible-heading -1)
    (recenter-top-bottom 2))

(define-key org-mode-map (kbd "M-n") #'kwrooijen/org-heading-1-next)
(define-key org-mode-map (kbd "M-p") #'kwrooijen/org-heading-1-prev)
#+END_SRC


#+BEGIN_SRC emacs-lisp
(plist-put org-format-latex-options :scale 2.5)
#+END_SRC



#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "M-p") 'org-previous-block)
(define-key org-mode-map (kbd "M-n") 'org-next-block)
(evil-define-key 'normal org-mode-map (kbd "RET") #'+org/dwim-at-point)
#+END_SRC


** Hook :hook:
#+BEGIN_SRC emacs-lisp
((org-mode . kwrooijen/org-mode-setup)
 (org-mode . org-margin-mode)
 (org-babel-after-execute . org-redisplay-inline-images)
 (org-babel-after-execute . kwrooijen/jupyter-color-fix)
 (org-src-mode . evil-normal-state))
#+END_SRC

** General :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/local-leader
  :keymaps 'org-src-mode-map
  "'" 'org-edit-src-exit
  "a" 'org-edit-src-abort)

(kwrooijen/local-leader
  :keymaps 'org-mode-map
  "'" 'org-edit-special
  "s s" 'kwrooijen/org-search-heading
  ", ," 'org-priority
  ", k" 'org-priority-up
  ", j" 'org-priority-down
  "i i" 'kwrooijen/org-images-increase
  "i j" 'kwrooijen/org-images-decrease
  "f b"  'org/toggle-bold
  "f u"  'org/toggle-underline
  "f i"  'org/toggle-italic
  "t a"  'kwrooijen/org-focus-this-heading
  "t i"  'org-toggle-inline-images
  "t e"  'kwrooijen/org-table-export
  "c t"  'org-clock-update-time-maybe
  "c s"  '(org-schedule :which-key "Org Schedule")
  "c d"  '(org-deadline :which-key "Org Deadline")
  "c i"  'org-clock-multi-clock-in
  "c o"  'org-clock-multi-clock-out
  "c O"  'org-clock-multi-clock-out-all
  "c r"  'org-clock-report
  "c x"  'org-clock-multi-clock-cancel
  "c X"  'org-clock-multi-clock-cancel-all
  "a l"  'org-agent-shell-launch
  "a s"  'org-agent-shell-open-shell
  "a g"  'org-agent-shell-open-magit
  "a d"  'org-agent-shell-diff
  "a r"  'org-agent-shell-resend
  "a v"  'org-agent-shell-review
  "a x"  'org-agent-shell-reset)
#+END_SRC

* Org Margin
:PROPERTIES:
:PACKAGE: org-margin
:STRAIGHT: (org-margin :host github :repo "rougier/org-margin")
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(require 'face-remap)
#+END_SRC
* Org Roam
:PROPERTIES:
:PACKAGE: org-roam
:STRAIGHT: t
:AFTER: org
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(org-roam-db-autosync-mode)
(require 'org-roam-protocol)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defvar kwrooijen/org-roam-projects
  '(("General" . "~/Documents/org/notes")
    ("AI" . "~/Documents/org/ai"))
  "List of org-roam projects.")

(defun kwrooijen/org-roam-switch-project (project)
  ;; Interactivelt select a project from list
  (interactive
   (list
    (completing-read "Project: " kwrooijen/org-roam-projects)))
  (setq org-roam-directory
        (file-truename
         (cdr (assoc project kwrooijen/org-roam-projects))))
  (org-roam-db-sync)
  (message "Switched to project: %s" project))
#+END_SRC

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(org-roam-directory (file-truename "~/Documents/org/notes"))
(org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
(org-roam-completion-everywhere t)
(org-roam-capture-templates '(("d" "default" plain "%?"
                                      :target (file+head "${slug}.org" "#+title: ${title} ")
                                      :unnarrowed t)
                                     ("e" "encrypt" plain "%?"
                                      :target (file+head "${slug}.org.gpg" "#+title: ${title} ")
                                      :unnarrowed t)))
#+END_SRC


** General :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
    "p o" 'kwrooijen/org-roam-switch-project)
#+END_SRC

* Prog Mode
:PROPERTIES:
:PACKAGE: prog-mode
:END:

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(prettify-symbols-alist '(("#+BEGIN_SRC" . "»")
                          ("#+END_SRC" . "«")
                          ("#+begin_src" . "»")
                          ("#+end_src" . "«")
                          ("#+begin_quote" . "“")
                          ("#+end_quote" . "”")
                          ("#+BEGIN_QUOTE" . "“")
                          ("#+END_QUOTE" . "”")
                          ("#+begin_example" . "“")
                          ("#+end_example" . "”")
                          ("#+BEGIN_EXAMPLE" . "“")
                          ("#+END_EXAMPLE" . "”")))
#+END_SRC

* Org Appear
:PROPERTIES:
:PACKAGE:  org-appear
:STRAIGHT: (org-appear :type git :host github :repo "awth13/org-appear")
:END:

** Hook :hook:
#+BEGIN_SRC emacs-lisp
((org-mode . org-appear-mode))
#+END_SRC

* Consult Notes
:PROPERTIES:
:PACKAGE:  consult-notes
:STRAIGHT: (consult-notes :type git :host github :repo "mclear-tools/consult-notes")
:END:

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(consult-notes-file-dir-sources '(("Notes"  ?n  "~/Documents/notes/")
                                  ("Old"  ?n  "~/Documents/org/notes/")))
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(consult-notes-org-roam-mode)
(consult-notes-denote-mode)
#+END_SRC

** General :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "fn" #'consult-notes
  "fp" #'consult-notes-search-in-all-notes)
#+END_SRC

* Org Fragtog
:PROPERTIES:
:PACKAGE:  org-fragtog
:STRAIGHT: t
:END:
** Hook :hook:
#+BEGIN_SRC emacs-lisp
((org-mode . org-fragtog-mode))
#+END_SRC

* Org Ql
:PROPERTIES:
:PACKAGE:  org-ql
:STRAIGHT: t
:END:


** Custom :custom:
#+BEGIN_SRC emacs-lisp
(org-ql-views
      `(("Notes"
         :buffers-files
,(directory-files
 "~/Documents/notes"
 t "\\.org$"))))
#+END_SRC

* Vertico
:PROPERTIES:
:PACKAGE:  vertico
:STRAIGHT: t
:END:

** Config :config:


#+BEGIN_SRC emacs-lisp
;; (defun kwrooijen/consult-grep-fix-tab ()
;;   (when (eq (completion-metadata-get
;;              (completion-metadata (minibuffer-contents)
;;                                   minibuffer-completion-table
;;                                   minibuffer-completion-predicate)
;;              'category)
;;             'consult-grep)
;;     (let ((map (make-sparse-keymap)))
;;       (define-key map (kbd "TAB")   #'ignore)
;;       (define-key map (kbd "<tab>") #'ignore)
;;       (setq-local minor-mode-overriding-map-alist
;;                   (cons `(vertico-mode . ,map)
;;                         minor-mode-overriding-map-alist)))
;;     ))

;; (add-hook 'minibuffer-setup-hook #'kwrooijen/consult-grep-fix-tab)
;; vertico-next-group is causing consult-rip-grep to break. Disabling it for now.
;; Attempted to override the keybinding with a hook, but that doesn't seem to work.
(defun vertico-next-group (&optional n) (interactive))
#+END_SRC


** General :general:
#+BEGIN_SRC emacs-lisp
(:keymaps 'minibuffer-local-map
          "M-c" #'clipboard-kill-ring-save
          "M-v" #'clipboard-yank

          ;; Navigation
          "C-f" #'scroll-up-command
          "C-b" #'scroll-down-command
          "C-h" #'backward-char
          "C-l" #'forward-char
          "C-j" #'next-line
          "C-k" #'previous-line
          "M-h" #'backward-word
          "M-l" #'forward-word

          ;; Deletion
          "C-d" #'delete-char
          "C-S-d" #'kill-line
          "M-d" #'kill-word

          ;; Other
          "M-]" (lambda() (interactive) (dimmer-restore-all)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "rr" '(vertico-repeat :which-key "Repeat last search"))
#+END_SRC

** Init :init:
#+BEGIN_SRC emacs-lisp
(vertico-mode)
(savehist-mode)
(recentf-mode)
#+END_SRC


** Custom :custom:
#+BEGIN_SRC emacs-lisp
(vertico-count 17)
(vertico-count-format '("%-9s " . "[%s/%s]"))
#+END_SRC

Allow nested minibuffers
#+BEGIN_SRC emacs-lisp
(enable-recursive-minibuffers t)
#+END_SRC

# Don't resize minibuffer
# #+BEGIN_SRC emacs-lisp
# (resize-mini-windows nil)
# #+END_SRC

** Hook :hook:
#+BEGIN_SRC emacs-lisp
('minibuffer-setup #'vertico-repeat-save)
#+END_SRC

* Consult
:PROPERTIES:
:PACKAGE:  consult
:STRAIGHT: t
:END:

** Hook :hook:
#+BEGIN_SRC emacs-lisp
(completion-list-mode . consult-preview-at-point-mode)
#+END_SRC

** Init :init:
#+BEGIN_SRC emacs-lisp
(advice-add #'register-preview :override #'consult-register-window)
#+END_SRC

** Custom :custom:

No delays
#+BEGIN_SRC emacs-lisp
(consult-async-refresh-delay 0)
(consult-async-input-debounce 0)
(consult-async-input-throttle 0)
(register-preview-delay nil)
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(consult-customize
 consult-line :preview-key 'any)

(consult-customize
 consult-theme
 consult-buffer
 consult-ripgrep consult-git-grep consult-grep consult-man
 consult-bookmark consult-recent-file consult-xref
 consult-source-bookmark consult-source-file-register
 consult-source-recent-file consult-source-project-recent-file
 kwrooijen/consult-ripgrep-symbol-at-point
 consult-notes-search-in-all-notes
 :preview-key "TAB")

;; Consult face overrides handled by embellish-theme
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/consult-ripgrep-symbol-at-point ()
  (interactive)
  (consult-ripgrep nil (thing-at-point 'symbol t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/minibuffer-disable-hl-line ()
  (with-current-buffer (window-buffer (minibuffer-selected-window))
    (hl-line-mode -1)))

(defun kwrooijen/minibuffer-restore-hl-line ()
  (with-current-buffer (window-buffer (minibuffer-selected-window))
    (hl-line-mode 1)))

(add-hook 'minibuffer-setup-hook #'kwrooijen/minibuffer-disable-hl-line)
(add-hook 'minibuffer-exit-hook #'kwrooijen/minibuffer-restore-hl-line)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/consult-peek-buffer ()
  "Temporarily peek at another buffer using popwin, restoring layout on quit."
  (interactive)
  (let* ((selected (consult--multi consult-buffer-sources
                                   :require-match
                                   (confirm-nonexistent-file-or-buffer)
                                   :prompt "Switch to: "
                                   :history 'consult--buffer-history
                                   :sort nil
                                   :state (lambda (_action _match))))
         (popwin-fn (lambda (buffer)
                      (popwin:display-buffer-1
                       buffer
                       :default-config-keywords '(:position left :width 0.5))))
         (type (when selected (plist-get (cdr selected) :name))))
    (when selected
      (pcase type
        ("Buffer"
         (funcall popwin-fn (car selected)))

        ("Bookmark"
         (let ((bookmark-buffer nil))
           (bookmark-jump (car selected) popwin-fn)))

        ("File"
         (funcall popwin-fn (find-file-noselect (car selected))))))))
#+END_SRC

Project find files

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/consult-project-find-file ()
  "Find a project file using `rg --files`, excluding .git/ but keeping .gitignore."
  (interactive)
  (let* ((root (project-root (project-current t)))
         (default-directory root)
         (rg (executable-find "rg")))
    (unless rg
      (user-error "ripgrep (rg) not found in PATH"))
    (let* ((files (process-lines rg
                                 "--files"
                                 "--color=never"
                                 "--hidden"
                                 "--follow"
                                 "--glob" "!.git/**"))
           (choice (consult--read files
                                  :prompt "Project file: "
                                  :sort nil
                                  :category 'file
                                  :history 'file-name-history)))
      (find-file (expand-file-name choice root)))))
#+END_SRC



** General :general:
#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "ss" '(consult-line :which-key "Find in buffer")
  "sp" '(consult-ripgrep :which-key "Grep in Project")
  "sP" '(kwrooijen/consult-ripgrep-symbol-at-point :which-key "Grep symbol in Project")
  "bb" '(consult-buffer :which-key "Switch buffer")
  "bp" '(kwrooijen/consult-peek-buffer :which-key "Peek buffer")
  "fb" '(consult-bookmark :which-key "Open bookmark")
  "ry" '(consult-yank-from-kill-ring :which-key "Kill ring")
  "pp" '(project-switch-project :which-key "Switch project")
  "pf" '(kwrooijen/consult-project-find-file :which-key "Find file in project"))
#+END_SRC

* Orderless
:PROPERTIES:
:PACKAGE:  orderless
:STRAIGHT: t
:END:

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(completion-styles '(orderless basic))
(completion-category-defaults nil)
;; (completion-category-overrides '((file (styles . (orderless)))))
(completion-category-overrides '((file (styles partial-completion))))
(completion-category-defaults nil)
(completion-pcm-leading-wildcard t)

(orderless-matching-styles '(orderless-literal orderless-prefixes))
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
;; Orderless face overrides handled by embellish-theme
#+END_SRC


* Marginalia
:PROPERTIES:
:PACKAGE:  marginalia
:STRAIGHT: t
:END:

** Init :init:
#+BEGIN_SRC emacs-lisp
(marginalia-mode)
#+END_SRC


* Embark
:PROPERTIES:
:PACKAGE:  embark
:STRAIGHT: t
:END:

** General :general:
#+BEGIN_SRC emacs-lisp
(general-define-key
 :keymaps '(minibuffer-mode-map embark-collect-mode-map)
 "M-e" 'embark-act
 "M-a" 'embark-act-all
 "M-b" 'embark-bindings
 "M-i" 'embark-select)
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))
#+END_SRC


* Embark Consult
:PROPERTIES:
:PACKAGE:  embark-consult
:STRAIGHT: t
:END:

** Hook :hook:
#+BEGIN_SRC emacs-lisp
(embark-collect-mode . consult-preview-at-point-mode)
#+END_SRC


* Wgrep
:PROPERTIES:
:PACKAGE:  wgrep
:STRAIGHT: t
:END:

** General :general:
#+BEGIN_SRC emacs-lisp
(:keymaps 'grep-mode-map
          :states 'normal
          "i" #'wgrep-change-to-wgrep-mode)

(:keymaps 'wgrep-mode-map
          "C-c C-c" #'wgrep-finish-edit)
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
;; Wgrep face overrides handled by embellish-theme
#+END_SRC


* Project
:PROPERTIES:
:PACKAGE:  project
:STRAIGHT: t
:END:

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(project-switch-commands 'project-find-file)
#+END_SRC

