#+STARTUP: showeverything

* Options

#+BEGIN_SRC emacs-lisp
(defcustom kwrooijen/snippet-directory
  (file-name-concat kwrooijen/emacs-directory "db/snippets")
  "Directory where snippets are stored."
  :type 'string
  :group 'kwrooijen)
#+END_SRC

* Yasnippet
:PROPERTIES:
:PACKAGE: yasnippet
:STRAIGHT: t
:END:

** Config :config:

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path kwrooijen/snippet-directory)
(add-to-list 'yas-snippet-dirs kwrooijen/snippet-directory)
(let ((yas-snippets-dir (expand-file-name "straight/repos/yasnippet-snippets/snippets" user-emacs-directory)))
  (add-to-list 'load-path kwrooijen/snippet-directory)
  (add-to-list 'yas-snippet-dirs kwrooijen/snippet-directory))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun kwrooijen/yas-completing-read (templates)
  "Prompt the user to select a template from TEMPLATES and insert its yasnippet.
TEMPLATES is an alist of (DISPLAY-NAME . SNIPPET-KEY) pairs."
  (interactive)
  (let* ((template-names (mapcar #'car templates))
         (selected (completing-read "Select template: " template-names nil t)))
    (when selected
      (let ((snippet-key (cdr (assoc selected templates))))
        (if (and (featurep 'yasnippet) (yas-lookup-snippet snippet-key))
            (yas-expand-snippet (yas-lookup-snippet snippet-key))
          (error "Yasnippet not available or snippet '%s' not found" snippet-key))))))
#+END_SRC



** Hook :hook:
#+BEGIN_SRC emacs-lisp
((prog-mode . yas-minor-mode)
 (org-mode . yas-minor-mode))
#+END_SRC


** Bindings :general:

#+BEGIN_SRC emacs-lisp
(kwrooijen/leader
  "i s" 'yas-insert-snippet)
#+END_SRC

* Yasnippet snippets
:PROPERTIES:
:PACKAGE: yasnippet-snippets
:STRAIGHT: t
:AFTER: yasnippet
:END:

** Jinx (spell checker)
:PROPERTIES:
:PACKAGE: jinx
:STRAIGHT: t
:END:

** Config :config:
#+BEGIN_SRC emacs-lisp
(defun kwrooijen/jinx-add-word-at-point ()
  "Add the word at point to Jinx personal dictionary."
  (interactive)
  (let ((word (thing-at-point 'word t)))
    (if (not word)
        (user-error "No word at point")
      ;; Call the same save logic that jinx uses for @word
      (jinx--save-personal 'save ?@ word)
      (jinx--recheck-overlays)
      (message "Added '%s' to Jinx personal dictionary" word))))
#+END_SRC

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(jinx-languages "en_US,nl")
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
("M-$" 'jinx-correct)
("C-M-$" 'jinx-languages)

(kwrooijen/leader
 "jj" 'kwrooijen/jinx-add-word-at-point
 "tt" '(jinx-mode :which-key "Jinx mode"))
#+END_SRC

** Hook :hook:

Jinx only uses spell checking inside comments (and maybe doc
strings?). Making it safe to enable in programming modes.

#+BEGIN_SRC emacs-lisp
((prog-mode . jinx-mode)
 (org-mode . jinx-mode))
#+END_SRC

* Copilot
:PROPERTIES:
:PACKAGE: copilot
:STRAIGHT: (:host github :repo "copilot-emacs/copilot.el" :files ("dist" "*.el"))
:END:

** Hooks :hook:
#+BEGIN_SRC emacs-lisp
((prog-mode . copilot-mode))
#+END_SRC

** Bindings :general:
#+BEGIN_SRC emacs-lisp
(:keymaps 'copilot-completion-map
          "M-TAB" 'copilot-accept-completion-by-word
          "M-<tab>" 'copilot-accept-completion-by-word
          "<tab>" 'kwrooijen/tab
          "TAB" 'kwrooijen/tab
          "C-<tab>" 'copilot-next-completion
          "C-TAB" 'copilot-next-completion)

(:states 'insert
  "C-o" 'copilot-next-completion)

("M-O" 'copilot-mode)

(kwrooijen/leader
 "to" '(copilot-mode :which-key "Copilot"))
#+END_SRC


** Init :init:
#+BEGIN_SRC emacs-lisp
(defun kwrooijen/copilot-disable ()
  (when (bound-and-true-p copilot-mode)
    (setq-local kwrooijen/copilot-was-enabled t)
    (copilot-mode -1)))

(defun kwrooijen/copilot-maybe-enable ()
  (when (and (bound-and-true-p kwrooijen/copilot-was-enabled)
             (not (bound-and-true-p corfu--popup)))
    (setq-local kwrooijen/copilot-was-enabled nil)
    (copilot-mode +1)))
#+END_SRC


* Aidermacs
:PROPERTIES:
:PACKAGE: aidermacs
:STRAIGHT: t
:END:

** Custom :custom:
#+BEGIN_SRC emacs-lisp
(aidermacs-show-diff-after-change nil)
(aidermacs-auto-commits nil)
(aidermacs-default-chat-mode 'code)
(aidermacs-extra-args '("--no-auto-commits"))
(aidermacs-default-model "openrouter/anthropic/claude-sonnet-4.5")
(aidermacs-weak-model "openrouter/x-ai/grok-code-fast-1")
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(define-advice aidermacs-run (:around (orig-fun &rest args) set-project-root)
  "Run aidermacs-run with default-directory set to project root."
  (let ((default-directory (kwrooijen/project-root)))
    (apply orig-fun args)))
#+END_SRC

# ** General :general:
# #+BEGIN_SRC emacs-lisp
# (kwrooijen/leader
# "a" 'aidermacs-transient-menu)
# #+END_SRC

* Eca
:PROPERTIES:
:PACKAGE:  eca
:STRAIGHT: t
:END:


* Corfu
:PROPERTIES:
:PACKAGE:  corfu
:STRAIGHT: t
:END:

** Init :init:
#+BEGIN_SRC emacs-lisp
(global-corfu-mode)
(corfu-popupinfo-mode)
(corfu-echo-mode)
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(add-hook 'corfu-mode-hook
          (lambda ()
            (add-hook 'corfu-popup-open-hook  #'kwrooijen/copilot-disable nil t)
            (add-hook 'corfu-popup-close-hook #'kwrooijen/copilot-maybe-enable nil t)))
#+END_SRC


** Custom :custom:
#+BEGIN_SRC emacs-lisp
(corfu-auto t)
(corfu-cycle t)
(tab-always-indent 'complete)
(text-mode-ispell-word-completion nil)
(read-extended-command-predicate #'command-completion-default-include-p)
(corfu-left-margin-width 24)
(corfu-right-margin-width 24)
#+END_SRC

Don't auto select the current selection
#+BEGIN_SRC emacs-lisp
(corfu-preview-current nil)
(corfu-on-exact-match nil)
(corfu-quit-no-match 'separator)
(corfu-quit-at-boundary t)
#+END_SRC


** General :general:
#+BEGIN_SRC emacs-lisp
(:keymaps 'corfu-map
  "C-f" #'corfu-scroll-up
  "C-b" #'corfu-scroll-down)
#+END_SRC

* Cape
:PROPERTIES:
:PACKAGE:  cape
:STRAIGHT: t
:END:

** General :general:
#+BEGIN_SRC emacs-lisp
("M-e" cape-prefix-map)
#+END_SRC

** Config :config:
#+BEGIN_SRC emacs-lisp
(add-hook 'completion-at-point-functions #'cape-dabbrev)
(add-hook 'completion-at-point-functions #'cape-file)
(add-hook 'completion-at-point-functions #'cape-elisp-block)

#+END_SRC

* Flymake
:PROPERTIES:
:PACKAGE:  flymake
:END:

** General :general:
#+BEGIN_SRC emacs-lisp
(:keymaps 'prog-mode-map
"M-n" #'flymake-goto-next-error
"M-p" #'flymake-goto-prev-error)
#+END_SRC

** Custom :custom:
Don't show indicator. NOTE: This causes the marker (exclamation mark)
to be displayed inside of the buffer, instead of the margin /
fringe. To hotfix this, go to the `flymake--highlight-line` function
and replace `"!"` with `""`. As of now there is no variable we can
adjust to fix this.
#+BEGIN_SRC emacs-lisp
(flymake-indicator-type nil)
(flymake-indicator-function #'ignore)
#+END_SRC

* Eglot
:PROPERTIES:
:PACKAGE:  eglot
:END:
